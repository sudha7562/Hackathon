"use strict";
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", { value: true });
exports.SqlPluginV3 = void 0;
const tslib_1 = require("tslib");
const teamsfx_api_1 = require("@microsoft/teamsfx-api");
const path = tslib_1.__importStar(require("path"));
const typedi_1 = require("typedi");
const constants_1 = require("../../../../common/constants");
const tools_1 = require("../../../../common/tools");
const folder_1 = require("../../../../folder");
const constants_2 = require("../../../solution/fx-solution/v3/constants");
const constants_3 = require("../constants");
const fs_extra_1 = tslib_1.__importDefault(require("fs-extra"));
const questions_1 = require("../questions");
const results_1 = require("../results");
const errors_1 = require("../errors");
const config_1 = require("../config");
const message_1 = require("../utils/message");
const dialogUtils_1 = require("../utils/dialogUtils");
const commonUtils_1 = require("../utils/commonUtils");
const sqlClient_1 = require("../sqlClient");
const CommonErrorHandlerMW_1 = require("../../../../core/middleware/CommonErrorHandlerMW");
const hooks_1 = require("@feathersjs/hooks");
const question_1 = require("../../../solution/fx-solution/question");
const managementClient_1 = require("../managementClient");
const solutionSettingsHelper_1 = require("../../../solution/fx-solution/utils/solutionSettingsHelper");
let SqlPluginV3 = class SqlPluginV3 {
    constructor() {
        this.name = constants_2.BuiltInFeaturePluginNames.sql;
        this.displayName = "Azure SQL Database";
        this.totalFirewallRuleCount = 0;
        this.config = new config_1.SqlConfig();
    }
    async generateBicep(ctx, inputs) {
        const solutionSettings = ctx.projectSetting.solutionSettings;
        const firstTime = !solutionSettings.activeResourcePlugins.includes(this.name);
        const armRes = firstTime
            ? await this.generateNewSqlServerBicep(ctx, inputs)
            : await this.generateNewDatabaseBicep();
        return armRes;
    }
    async generateNewSqlServerBicep(ctx, inputs) {
        const pluginCtx = { plugins: inputs.allPluginsAfterAdd };
        const bicepTemplateDirectory = path.join(folder_1.getTemplatesFolder(), "plugins", "resource", "sql", "bicep");
        const provisionOrchestration = await tools_1.generateBicepFromFile(path.join(bicepTemplateDirectory, constants_3.AzureSqlBicepFile.moduleTemplateFileName), pluginCtx);
        const provisionModules = await tools_1.generateBicepFromFile(path.join(bicepTemplateDirectory, constants_3.AzureSqlBicepFile.ProvisionModuleTemplateFileName), pluginCtx);
        const result = {
            Provision: {
                Orchestration: provisionOrchestration,
                Modules: { azureSql: provisionModules },
            },
            Parameters: await fs_extra_1.default.readJSON(path.join(bicepTemplateDirectory, constants_1.Bicep.ParameterFileName)),
            Reference: {
                sqlResourceId: constants_3.AzureSqlBicep.sqlResourceId,
                sqlEndpoint: constants_3.AzureSqlBicep.sqlEndpoint,
                databaseName: constants_3.AzureSqlBicep.databaseName,
            },
        };
        return teamsfx_api_1.ok([result]);
    }
    async generateNewDatabaseBicep() {
        const suffix = tools_1.getUuid().substring(0, 6);
        const compileCtx = {
            suffix: suffix,
        };
        const bicepTemplateDirectory = path.join(folder_1.getTemplatesFolder(), "plugins", "resource", "sql", "bicep");
        const provisionOrchestration = await tools_1.generateBicepFromFile(path.join(bicepTemplateDirectory, constants_3.AzureSqlBicepFile.newDatabaseOrchestrationTemplateFileName), compileCtx);
        const provisionModules = await tools_1.generateBicepFromFile(path.join(bicepTemplateDirectory, constants_3.AzureSqlBicepFile.newDatabaseProvisionTemplateFileName), compileCtx);
        const result = {
            Provision: {
                Orchestration: provisionOrchestration,
                Modules: { azureSql: provisionModules },
            },
            Reference: {
                sqlResourceId: constants_3.AzureSqlBicep.sqlResourceId,
                sqlEndpoint: constants_3.AzureSqlBicep.sqlEndpoint,
                databaseName: constants_3.AzureSqlBicep.databaseName,
            },
        };
        return teamsfx_api_1.ok([result]);
    }
    async addInstance(ctx, inputs) {
        solutionSettingsHelper_1.ensureSolutionSettings(ctx.projectSetting);
        const solutionSettings = ctx.projectSetting.solutionSettings;
        const activeResourcePlugins = solutionSettings.activeResourcePlugins;
        if (!activeResourcePlugins.includes(this.name))
            activeResourcePlugins.push(this.name);
        if (!solutionSettings.azureResources.includes(question_1.AzureResourceSQL.id))
            solutionSettings.azureResources.push(question_1.AzureResourceSQL.id);
        return teamsfx_api_1.ok([constants_2.BuiltInFeaturePluginNames.identity]);
    }
    async updateBicep(ctx, inputs) {
        const result = {
            Reference: {
                sqlResourceId: constants_3.AzureSqlBicep.sqlResourceId,
                sqlEndpoint: constants_3.AzureSqlBicep.sqlEndpoint,
                databaseName: constants_3.AzureSqlBicep.databaseName,
            },
        };
        return teamsfx_api_1.ok([result]);
    }
    async getQuestionsForProvision(ctx, inputs, envInfo, tokenProvider) {
        await this.loadConfig(envInfo, tokenProvider.azureAccountProvider);
        await managementClient_1.SqlMgrClient.create(tokenProvider.azureAccountProvider, this.config);
        this.config.existSql = await managementClient_1.SqlMgrClient.existAzureSQL();
        if (!this.config.existSql || inputs.platform === teamsfx_api_1.Platform.CLI_HELP) {
            // sql question will be returned in two cases:
            // 1. CLI_HELP; 2. SQL not exists
            const sqlNode = new teamsfx_api_1.QTreeNode({
                type: "group",
            });
            sqlNode.addChild(new teamsfx_api_1.QTreeNode(questions_1.adminNameQuestion));
            sqlNode.addChild(new teamsfx_api_1.QTreeNode(questions_1.adminPasswordQuestion));
            sqlNode.addChild(new teamsfx_api_1.QTreeNode(questions_1.confirmPasswordQuestion));
            return teamsfx_api_1.ok(sqlNode);
        }
        return teamsfx_api_1.ok(undefined);
    }
    getRuleName(suffix) {
        return constants_3.Constants.firewall.localRule + suffix;
    }
    removeDatabases(envInfo) {
        const sqlResource = envInfo.state[constants_2.BuiltInFeaturePluginNames.sql];
        if (sqlResource) {
            for (const key of Object.keys(sqlResource)) {
                if (key.startsWith(constants_3.Constants.databaseName) && key !== constants_3.Constants.databaseName) {
                    delete sqlResource[key];
                }
            }
        }
    }
    async parseLoginToken(azureAccountProvider) {
        // get login user info to set aad admin in sql
        try {
            const credential = await azureAccountProvider.getAccountCredentialAsync();
            const token = await credential.getToken();
            const accessToken = token.accessToken;
            const tokenInfo = commonUtils_1.parseToken(accessToken);
            this.config.aadAdmin = tokenInfo.name;
            this.config.aadAdminObjectId = tokenInfo.objectId;
            this.config.aadAdminType = tokenInfo.userType;
        }
        catch (error) {
            throw results_1.SqlResultFactory.SystemError(errors_1.ErrorMessage.SqlUserInfoError.name, errors_1.ErrorMessage.SqlUserInfoError.message(), error);
        }
    }
    async provisionResource(ctx, inputs, envInfo, tokenProvider) {
        ctx.logProvider.info(message_1.Message.startPreProvision);
        this.removeDatabases(envInfo);
        await this.loadConfig(envInfo, tokenProvider.azureAccountProvider);
        await managementClient_1.SqlMgrClient.create(tokenProvider.azureAccountProvider, this.config);
        dialogUtils_1.DialogUtils.init(ctx.userInteraction);
        this.config.existSql = await managementClient_1.SqlMgrClient.existAzureSQL();
        if (!this.config.existSql) {
            this.config.admin = inputs[constants_3.Constants.questionKey.adminName];
            this.config.adminPassword = inputs[constants_3.Constants.questionKey.adminPassword];
            if (!this.config.admin || !this.config.adminPassword) {
                throw results_1.SqlResultFactory.SystemError(errors_1.ErrorMessage.SqlInputError.name, errors_1.ErrorMessage.SqlInputError.message());
            }
        }
        await this.parseLoginToken(tokenProvider.azureAccountProvider);
        const sqlResource = envInfo.state[this.name];
        sqlResource.admin = this.config.admin;
        sqlResource.adminPassword = this.config.adminPassword;
        ctx.logProvider.info(message_1.Message.endPreProvision);
        return teamsfx_api_1.ok(teamsfx_api_1.Void);
    }
    async configureResource(ctx, inputs, envInfo, tokenProvider, telemetryProps) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l;
        (_a = ctx.logProvider) === null || _a === void 0 ? void 0 : _a.info(message_1.Message.startPostProvision);
        await this.loadConfig(envInfo, tokenProvider.azureAccountProvider);
        //delete admin password
        const sqlState = envInfo.state[this.name];
        delete sqlState[constants_3.Constants.adminPassword];
        await managementClient_1.SqlMgrClient.create(tokenProvider.azureAccountProvider, this.config);
        dialogUtils_1.DialogUtils.init(ctx.userInteraction, dialogUtils_1.ProgressTitle.PostProvision, Object.keys(dialogUtils_1.ConfigureMessage).length);
        if (telemetryProps) {
            telemetryProps[constants_3.Telemetry.properties.skipAddingUser] = this.config.skipAddingUser
                ? constants_3.Telemetry.valueYes
                : constants_3.Telemetry.valueNo;
            telemetryProps[constants_3.Telemetry.properties.dbCount] = this.config.databases.length.toString();
        }
        (_b = ctx.logProvider) === null || _b === void 0 ? void 0 : _b.info(message_1.Message.addFirewall);
        await managementClient_1.SqlMgrClient.addLocalFirewallRule();
        await ((_c = dialogUtils_1.DialogUtils.progressBar) === null || _c === void 0 ? void 0 : _c.start());
        await ((_d = dialogUtils_1.DialogUtils.progressBar) === null || _d === void 0 ? void 0 : _d.next(dialogUtils_1.ConfigureMessage.postProvisionAddAadmin));
        await this.CheckAndSetAadAdmin(ctx, managementClient_1.SqlMgrClient);
        this.getIdentity(envInfo);
        if (!this.config.skipAddingUser) {
            await ((_e = dialogUtils_1.DialogUtils.progressBar) === null || _e === void 0 ? void 0 : _e.next(dialogUtils_1.ConfigureMessage.postProvisionAddUser));
            // azure sql does not support service principal admin to add databse user currently, so just notice developer if so.
            if (this.config.aadAdminType === commonUtils_1.UserType.User) {
                (_f = ctx.logProvider) === null || _f === void 0 ? void 0 : _f.info(message_1.Message.connectDatabase);
                const sqlClient = await sqlClient_1.SqlClient.create(tokenProvider.azureAccountProvider, this.config);
                (_g = ctx.logProvider) === null || _g === void 0 ? void 0 : _g.info(message_1.Message.addDatabaseUser(this.config.identity));
                await this.addDatabaseUser(ctx, sqlClient, managementClient_1.SqlMgrClient);
            }
            else {
                const message = errors_1.ErrorMessage.ServicePrincipalWarning(this.config.identity, this.config.databaseName);
                (_h = ctx.logProvider) === null || _h === void 0 ? void 0 : _h.warning(`[${constants_3.Constants.pluginName}] ${message}. You can follow ${constants_3.HelpLinks.default} to add database user ${this.config.identity}`);
            }
        }
        else {
            (_j = ctx.logProvider) === null || _j === void 0 ? void 0 : _j.warning(`[${constants_3.Constants.pluginName}] Skip adding database user. You can follow ${constants_3.HelpLinks.default} to add database user ${this.config.identity}`);
        }
        await managementClient_1.SqlMgrClient.deleteLocalFirewallRule();
        (_k = ctx.logProvider) === null || _k === void 0 ? void 0 : _k.info(message_1.Message.endPostProvision);
        await ((_l = dialogUtils_1.DialogUtils.progressBar) === null || _l === void 0 ? void 0 : _l.end(true));
        return teamsfx_api_1.ok(teamsfx_api_1.Void);
    }
    async addDatabaseUser(ctx, sqlClient, managementClient) {
        var _a;
        let retryCount = 0;
        const databaseWithUser = {};
        this.config.databases.forEach((element) => {
            databaseWithUser[element] = false;
        });
        while (true) {
            try {
                for (const database in databaseWithUser) {
                    if (!databaseWithUser[database]) {
                        await sqlClient.addDatabaseUser(database);
                        databaseWithUser[database] = true;
                    }
                }
                return;
            }
            catch (error) {
                if (!sqlClient_1.SqlClient.isFireWallError(error === null || error === void 0 ? void 0 : error.innerError) ||
                    retryCount >= constants_3.Constants.maxRetryTimes) {
                    throw error;
                }
                else {
                    retryCount++;
                    (_a = ctx.logProvider) === null || _a === void 0 ? void 0 : _a.warning(`[${constants_3.Constants.pluginName}] Retry adding new firewall rule to access azure sql, because the local IP address has changed after added firewall rule for it. [Retry time: ${retryCount}]`);
                    await managementClient.addLocalFirewallRule();
                }
            }
        }
    }
    async CheckAndSetAadAdmin(ctx, client) {
        var _a, _b, _c;
        (_a = ctx.logProvider) === null || _a === void 0 ? void 0 : _a.info(message_1.Message.checkAadAdmin);
        const existAdmin = await client.existAadAdmin();
        if (!existAdmin) {
            (_b = ctx.logProvider) === null || _b === void 0 ? void 0 : _b.info(message_1.Message.addSqlAadAdmin);
            await client.addAADadmin();
        }
        else {
            (_c = ctx.logProvider) === null || _c === void 0 ? void 0 : _c.info(message_1.Message.skipAddAadAdmin);
        }
    }
    getIdentity(envInfo) {
        const identityConfig = envInfo.state[constants_3.Constants.identityPlugin];
        this.config.identity = identityConfig === null || identityConfig === void 0 ? void 0 : identityConfig.identityName;
        if (!this.config.identity) {
            const error = results_1.SqlResultFactory.SystemError(errors_1.ErrorMessage.SqlGetConfigError.name, errors_1.ErrorMessage.SqlGetConfigError.message(constants_3.Constants.identityPlugin, constants_3.Constants.identityName));
            throw error;
        }
    }
    loadConfigSql(sqlResource) {
        this.config.sqlEndpoint = sqlResource.sqlEndpoint;
        this.config.admin = sqlResource.admin;
        this.config.adminPassword = sqlResource.adminPassword;
        this.config.databaseName = sqlResource.databaseName;
        if (this.config.sqlEndpoint) {
            this.config.sqlServer = this.config.sqlEndpoint.split(".")[0];
        }
    }
    loadDatabases(sqlResource) {
        for (const key of Object.keys(sqlResource)) {
            if (key.startsWith(constants_3.Constants.databaseName)) {
                const value = sqlResource[key];
                this.config.databases.push(value);
            }
        }
    }
    async loadConfig(envInfo, azureAccountProvider) {
        var _a;
        const sqlResource = envInfo.state[constants_2.BuiltInFeaturePluginNames.sql];
        if (sqlResource) {
            this.config.sqlResourceId = sqlResource.sqlResourceId;
            if (this.config.sqlResourceId) {
                try {
                    this.config.azureSubscriptionId = tools_1.getSubscriptionIdFromResourceId(this.config.sqlResourceId);
                }
                catch (error) {
                    throw results_1.SqlResultFactory.UserError(errors_1.ErrorMessage.SqlInvalidConfigError.name, errors_1.ErrorMessage.SqlInvalidConfigError.message(this.config.sqlResourceId, error.message), error);
                }
                try {
                    this.config.resourceGroup = tools_1.getResourceGroupNameFromResourceId(this.config.sqlResourceId);
                }
                catch (error) {
                    throw results_1.SqlResultFactory.UserError(errors_1.ErrorMessage.SqlInvalidConfigError.name, errors_1.ErrorMessage.SqlInvalidConfigError.message(this.config.sqlResourceId, error.message), error);
                }
            }
            this.loadConfigSql(sqlResource);
            this.loadDatabases(sqlResource);
        }
        const solutionConfig = envInfo.state.solution;
        this.config.resourceNameSuffix = solutionConfig.resourceNameSuffix;
        this.config.location = solutionConfig.location;
        this.config.tenantId = solutionConfig.tenantId;
        const skipAddingUser = (_a = envInfo.config) === null || _a === void 0 ? void 0 : _a[constants_3.Constants.skipAddingSqlUser];
        if (skipAddingUser === undefined) {
            this.config.skipAddingUser = (await (azureAccountProvider === null || azureAccountProvider === void 0 ? void 0 : azureAccountProvider.getIdentityCredentialAsync()))
                ? false
                : true;
        }
        else {
            this.config.skipAddingUser = skipAddingUser;
        }
    }
};
tslib_1.__decorate([
    hooks_1.hooks([CommonErrorHandlerMW_1.CommonErrorHandlerMW({ telemetry: { component: constants_2.BuiltInFeaturePluginNames.sql } })]),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [Object, Object]),
    tslib_1.__metadata("design:returntype", Promise)
], SqlPluginV3.prototype, "addInstance", null);
tslib_1.__decorate([
    hooks_1.hooks([CommonErrorHandlerMW_1.CommonErrorHandlerMW({ telemetry: { component: constants_2.BuiltInFeaturePluginNames.sql } })]),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [Object, Object]),
    tslib_1.__metadata("design:returntype", Promise)
], SqlPluginV3.prototype, "updateBicep", null);
tslib_1.__decorate([
    hooks_1.hooks([
        CommonErrorHandlerMW_1.CommonErrorHandlerMW({
            telemetry: {
                component: constants_2.BuiltInFeaturePluginNames.sql,
                eventName: constants_3.Telemetry.stage.preProvision,
            },
        }),
    ]),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [Object, Object, Object, Object]),
    tslib_1.__metadata("design:returntype", Promise)
], SqlPluginV3.prototype, "provisionResource", null);
tslib_1.__decorate([
    hooks_1.hooks([
        CommonErrorHandlerMW_1.CommonErrorHandlerMW({
            telemetry: {
                component: constants_2.BuiltInFeaturePluginNames.sql,
                eventName: constants_3.Telemetry.stage.postProvision,
            },
        }),
    ]),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [Object, Object, Object, Object, Object]),
    tslib_1.__metadata("design:returntype", Promise)
], SqlPluginV3.prototype, "configureResource", null);
SqlPluginV3 = tslib_1.__decorate([
    typedi_1.Service(constants_2.BuiltInFeaturePluginNames.sql)
], SqlPluginV3);
exports.SqlPluginV3 = SqlPluginV3;
//# sourceMappingURL=index.js.map