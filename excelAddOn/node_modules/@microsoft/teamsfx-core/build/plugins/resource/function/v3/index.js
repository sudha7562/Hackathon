"use strict";
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", { value: true });
exports.FunctionPluginV3 = void 0;
const tslib_1 = require("tslib");
const lib_1 = require("@feathersjs/hooks/lib");
const teamsfx_api_1 = require("@microsoft/teamsfx-api");
const path = tslib_1.__importStar(require("path"));
const typedi_1 = require("typedi");
const constants_1 = require("../../../../common/constants");
const checkerFactory_1 = require("../../../../common/deps-checker/checkerFactory");
const depsChecker_1 = require("../../../../common/deps-checker/depsChecker");
const depsError_1 = require("../../../../common/deps-checker/depsError");
const tools_1 = require("../../../../common/tools");
const utils_1 = require("../../../../common/utils");
const CommonErrorHandlerMW_1 = require("../../../../core/middleware/CommonErrorHandlerMW");
const folder_1 = require("../../../../folder");
const question_1 = require("../../../solution/fx-solution/question");
const solutionSettingsHelper_1 = require("../../../solution/fx-solution/utils/solutionSettingsHelper");
const constants_2 = require("../../../solution/fx-solution/v3/constants");
const constants_3 = require("../constants");
const enums_1 = require("../enums");
const deploy_1 = require("../ops/deploy");
const provision_1 = require("../ops/provision");
const scaffold_1 = require("../ops/scaffold");
const question_2 = require("../question");
const errors_1 = require("../resources/errors");
const message_1 = require("../resources/message");
const steps_1 = require("../resources/steps");
const azure_client_1 = require("../utils/azure-client");
const funcHelper_1 = require("../utils/depsChecker/funcHelper");
const funcPluginLogger_1 = require("../utils/depsChecker/funcPluginLogger");
const funcPluginTelemetry_1 = require("../utils/depsChecker/funcPluginTelemetry");
const telemetry_helper_1 = require("../utils/telemetry-helper");
const error_1 = require("./error");
let FunctionPluginV3 = class FunctionPluginV3 {
    constructor() {
        this.name = constants_2.BuiltInFeaturePluginNames.function;
        this.displayName = "Azure Function";
        this.config = {
            skipDeploy: false,
        };
    }
    getFunctionProjectRootPath(projectPath) {
        return path.join(projectPath, constants_3.FunctionPluginPathInfo.solutionFolderName);
    }
    async getQuestionsForAddInstance(ctx, inputs) {
        const projectPath = inputs.projectPath;
        question_2.functionNameQuestion.validation = {
            validFunc: async (input, previousInputs) => {
                var _a;
                if (!projectPath)
                    return undefined;
                const workingPath = this.getFunctionProjectRootPath(projectPath);
                const name = input;
                if (!name || !constants_3.RegularExpr.validFunctionNamePattern.test(name)) {
                    return message_1.ErrorMessages.invalidFunctionName;
                }
                const language = (_a = inputs[enums_1.QuestionKey.programmingLanguage]) !== null && _a !== void 0 ? _a : ctx.projectSetting.programmingLanguage;
                // If language is unknown, skip checking and let scaffold handle the error.
                if (language &&
                    (await scaffold_1.FunctionScaffold.doesFunctionPathExist(workingPath, language, name))) {
                    return message_1.ErrorMessages.functionAlreadyExists;
                }
            },
        };
        return teamsfx_api_1.ok(new teamsfx_api_1.QTreeNode(question_2.functionNameQuestion));
    }
    async syncConfigFromContext(ctx, inputs, envInfo) {
        var _a, _b;
        this.config.functionLanguage = ctx.projectSetting.programmingLanguage;
        this.config.defaultFunctionName = ctx.projectSetting.defaultFunctionName;
        this.config.functionEndpoint = (_a = envInfo === null || envInfo === void 0 ? void 0 : envInfo.state[this.name]) === null || _a === void 0 ? void 0 : _a.functionEndpoint;
        this.config.functionAppResourceId = (_b = envInfo === null || envInfo === void 0 ? void 0 : envInfo.state[this.name]) === null || _b === void 0 ? void 0 : _b.functionAppResourceId;
        /* Always validate after sync for safety and security. */
        this.validateConfig();
    }
    syncConfigToContext(ctx, inputs, envInfo) {
        // sync plugin config to context
        Object.entries(this.config)
            .filter((kv) => constants_3.FunctionPluginInfo.FunctionPluginPersistentConfig.find((x) => x === kv[0]))
            .forEach((kv) => {
            if (kv[1]) {
                envInfo.state[this.name][kv[0]] = kv[1].toString();
            }
        });
        // sync project settings to context
        if (this.config.defaultFunctionName) {
            ctx.projectSetting.defaultFunctionName = this.config.defaultFunctionName;
        }
    }
    validateConfig() {
        if (this.config.functionLanguage &&
            !Object.values(enums_1.FunctionLanguage).includes(this.config.functionLanguage)) {
            throw new error_1.ValidationError(enums_1.FunctionConfigKey.functionLanguage);
        }
        if (this.config.resourceNameSuffix &&
            !constants_3.RegularExpr.validResourceSuffixPattern.test(this.config.resourceNameSuffix)) {
            throw new error_1.ValidationError(enums_1.FunctionConfigKey.resourceNameSuffix);
        }
        if (this.config.functionAppName &&
            !constants_3.RegularExpr.validFunctionAppNamePattern.test(this.config.functionAppName)) {
            throw new error_1.ValidationError(enums_1.FunctionConfigKey.functionAppName);
        }
        if (this.config.storageAccountName &&
            !constants_3.RegularExpr.validStorageAccountNamePattern.test(this.config.storageAccountName)) {
            throw new error_1.ValidationError(enums_1.FunctionConfigKey.storageAccountName);
        }
        if (this.config.appServicePlanName &&
            !constants_3.RegularExpr.validAppServicePlanNamePattern.test(this.config.appServicePlanName)) {
            throw new error_1.ValidationError(enums_1.FunctionConfigKey.appServicePlanName);
        }
        if (this.config.defaultFunctionName &&
            !constants_3.RegularExpr.validFunctionNamePattern.test(this.config.defaultFunctionName)) {
            throw new error_1.ValidationError(enums_1.FunctionConfigKey.defaultFunctionName);
        }
    }
    checkAndGet(v, key) {
        if (v) {
            return v;
        }
        throw new error_1.FetchConfigError(key);
    }
    async generateCode(ctx, inputs) {
        var _a;
        await this.syncConfigFromContext(ctx, inputs);
        const workingPath = this.getFunctionProjectRootPath(inputs.projectPath);
        const functionLanguage = this.checkAndGet(this.config.functionLanguage, enums_1.FunctionConfigKey.functionLanguage);
        const name = (_a = inputs[enums_1.QuestionKey.functionName]) !== null && _a !== void 0 ? _a : constants_3.DefaultValues.functionName;
        if (await scaffold_1.FunctionScaffold.doesFunctionPathExist(workingPath, functionLanguage, name)) {
            throw new error_1.FunctionNameConflictError();
        }
        this.config.functionName = name;
        const functionName = this.checkAndGet(this.config.functionName, enums_1.FunctionConfigKey.functionName);
        await scaffold_1.FunctionScaffold.scaffoldFunction(workingPath, functionLanguage, constants_3.DefaultValues.functionTriggerType, functionName, {
            appName: utils_1.convertToAlphanumericOnly(ctx.projectSetting.appName),
            functionName: functionName,
        });
        if (!this.config.defaultFunctionName) {
            this.config.defaultFunctionName = this.config.functionName;
        }
        return teamsfx_api_1.ok(teamsfx_api_1.Void);
    }
    async generateBicep(ctx, inputs) {
        const solutionSettings = ctx.projectSetting.solutionSettings;
        if (solutionSettings.activeResourcePlugins.includes(this.name))
            return teamsfx_api_1.ok([]);
        const pluginCtx = { plugins: inputs.allPluginsAfterAdd };
        const bicepTemplateDirectory = path.join(folder_1.getTemplatesFolder(), "plugins", "resource", "function", "bicep");
        const provisionTemplateFilePath = path.join(bicepTemplateDirectory, constants_1.Bicep.ProvisionFileName);
        const provisionFuncTemplateFilePath = path.join(bicepTemplateDirectory, constants_3.FunctionBicepFile.provisionModuleTemplateFileName);
        const configTemplateFilePath = path.join(bicepTemplateDirectory, constants_1.Bicep.ConfigFileName);
        const configFuncTemplateFilePath = path.join(bicepTemplateDirectory, constants_3.FunctionBicepFile.configuraitonTemplateFileName);
        const provisionOrchestration = await tools_1.generateBicepFromFile(provisionTemplateFilePath, pluginCtx);
        const provisionModule = await tools_1.generateBicepFromFile(provisionFuncTemplateFilePath, pluginCtx);
        const configOrchestration = await tools_1.generateBicepFromFile(configTemplateFilePath, pluginCtx);
        const configModule = await tools_1.generateBicepFromFile(configFuncTemplateFilePath, pluginCtx);
        const result = {
            Provision: {
                Orchestration: provisionOrchestration,
                Modules: { function: provisionModule },
            },
            Configuration: {
                Orchestration: configOrchestration,
                Modules: { function: configModule },
            },
            Reference: {
                functionAppResourceId: constants_3.FunctionBicep.functionAppResourceId,
                functionEndpoint: constants_3.FunctionBicep.functionEndpoint,
            },
        };
        return teamsfx_api_1.ok([result]);
    }
    async updateBicep(ctx, inputs) {
        const bicepTemplateDirectory = path.join(folder_1.getTemplatesFolder(), "plugins", "resource", "function", "bicep");
        const pluginCtx = { plugins: inputs.allPluginsAfterAdd };
        const configFuncTemplateFilePath = path.join(bicepTemplateDirectory, constants_3.FunctionBicepFile.configuraitonTemplateFileName);
        const configModule = await tools_1.generateBicepFromFile(configFuncTemplateFilePath, pluginCtx);
        const result = {
            Reference: {
                functionAppResourceId: constants_3.FunctionBicep.functionAppResourceId,
                functionEndpoint: constants_3.FunctionBicep.functionEndpoint,
            },
            Configuration: {
                Modules: { function: configModule },
            },
        };
        return teamsfx_api_1.ok([result]);
    }
    async addInstance(ctx, inputs) {
        solutionSettingsHelper_1.ensureSolutionSettings(ctx.projectSetting);
        const solutionSettings = ctx.projectSetting.solutionSettings;
        const azureResources = solutionSettings.azureResources;
        const activeResourcePlugins = solutionSettings.activeResourcePlugins;
        if (!azureResources.includes(question_1.AzureResourceFunction.id))
            azureResources.push(question_1.AzureResourceFunction.id);
        if (!activeResourcePlugins.includes(this.name))
            activeResourcePlugins.push(this.name);
        return teamsfx_api_1.ok([constants_2.BuiltInFeaturePluginNames.identity]);
    }
    needConfigure(ctx, envInfo) {
        const apimConfig = envInfo.state[constants_2.BuiltInFeaturePluginNames.apim];
        return this.isPluginEnabled(ctx.projectSetting, constants_2.BuiltInFeaturePluginNames.apim) && !!apimConfig;
    }
    getFunctionAppName() {
        return tools_1.getSiteNameFromResourceId(this.checkAndGet(this.config.functionAppResourceId, enums_1.FunctionConfigKey.functionAppResourceId));
    }
    getFunctionAppResourceGroupName() {
        return tools_1.getResourceGroupNameFromResourceId(this.checkAndGet(this.config.functionAppResourceId, enums_1.FunctionConfigKey.functionAppResourceId));
    }
    getFunctionAppSubscriptionId() {
        return tools_1.getSubscriptionIdFromResourceId(this.checkAndGet(this.config.functionAppResourceId, enums_1.FunctionConfigKey.functionAppResourceId));
    }
    async getSite(client, resourceGroupName, functionAppName) {
        const site = await azure_client_1.AzureLib.findFunctionApp(client, resourceGroupName, functionAppName);
        if (!site) {
            throw new error_1.FindAppError();
        }
        else {
            return site;
        }
    }
    collectFunctionAppSettings(ctx, envInfo, site) {
        const apimConfig = envInfo.state[constants_2.BuiltInFeaturePluginNames.apim];
        if (this.isPluginEnabled(ctx.projectSetting, constants_2.BuiltInFeaturePluginNames.apim) && apimConfig) {
            ctx.logProvider.info(message_1.InfoMessages.dependPluginDetected(constants_2.BuiltInFeaturePluginNames.apim));
            const clientId = this.checkAndGet(apimConfig.apimClientAADClientId, "APIM app Id");
            provision_1.FunctionProvision.ensureFunctionAllowAppIds(site, [clientId]);
        }
    }
    isPluginEnabled(projectSettings, plugin) {
        const selectedPlugins = projectSettings.solutionSettings
            ? projectSettings.solutionSettings.activeResourcePlugins
            : [];
        return selectedPlugins.includes(plugin);
    }
    async configureResource(ctx, inputs, envInfo, tokenProvider) {
        if (!this.needConfigure(ctx, envInfo)) {
            return teamsfx_api_1.ok(teamsfx_api_1.Void);
        }
        await steps_1.StepHelperFactory.postProvisionStepHelper.start(Object.entries(steps_1.PostProvisionSteps).length, ctx.userInteraction);
        await this.syncConfigFromContext(ctx, inputs, envInfo);
        const functionAppName = this.getFunctionAppName();
        const resourceGroupName = this.getFunctionAppResourceGroupName();
        const subscriptionId = this.getFunctionAppSubscriptionId();
        const credential = this.checkAndGet(await tokenProvider.azureAccountProvider.getAccountCredentialAsync(), enums_1.FunctionConfigKey.credential);
        const webSiteManagementClient = await errors_1.runWithErrorCatchAndThrow(new error_1.InitAzureSDKError(), () => azure_client_1.AzureClientFactory.getWebSiteManagementClient(credential, subscriptionId));
        const site = await this.getSite(webSiteManagementClient, resourceGroupName, functionAppName);
        // We must query app settings from azure here, for two reasons:
        // 1. The site object returned by SDK may not contain app settings.
        // 2. Azure automatically added some app settings during creation.
        const res = await errors_1.runWithErrorCatchAndThrow(new error_1.ConfigFunctionAppError(), async () => await webSiteManagementClient.webApps.listApplicationSettings(resourceGroupName, functionAppName));
        if (res.properties) {
            Object.entries(res.properties).forEach((kv) => {
                // The site have some settings added in provision step,
                // which should not be overwritten by queried settings.
                provision_1.FunctionProvision.pushAppSettings(site, kv[0], kv[1], false);
            });
        }
        this.collectFunctionAppSettings(ctx, envInfo, site);
        await errors_1.runWithErrorCatchAndThrow(new error_1.ConfigFunctionAppError(), async () => await steps_1.step(steps_1.StepGroup.PostProvisionStepGroup, steps_1.PostProvisionSteps.updateFunctionSettings, async () => await webSiteManagementClient.webApps.update(resourceGroupName, functionAppName, site)));
        ctx.logProvider.info(message_1.InfoMessages.functionAppSettingsUpdated);
        this.syncConfigToContext(ctx, inputs, envInfo);
        await steps_1.StepHelperFactory.postProvisionStepHelper.end(true);
        return teamsfx_api_1.ok(teamsfx_api_1.Void);
    }
    async handleDotnetChecker(inputs) {
        const dotnetChecker = checkerFactory_1.CheckerFactory.createChecker(depsChecker_1.DepsType.Dotnet, funcPluginLogger_1.funcDepsLogger, funcPluginTelemetry_1.funcDepsTelemetry);
        await steps_1.step(steps_1.StepGroup.PreDeployStepGroup, steps_1.PreDeploySteps.dotnetInstall, async () => {
            try {
                if (!(await funcHelper_1.funcDepsHelper.dotnetCheckerEnabled(inputs))) {
                    return;
                }
                await dotnetChecker.resolve();
            }
            catch (error) {
                if (error instanceof depsError_1.LinuxNotSupportedError) {
                    return;
                }
                funcPluginLogger_1.funcDepsLogger.error(message_1.InfoMessages.failedToInstallDotnet(error));
                await funcPluginLogger_1.funcDepsLogger.printDetailLog();
                throw funcHelper_1.funcDepsHelper.transferError(error);
            }
            finally {
                funcPluginLogger_1.funcDepsLogger.cleanup();
            }
        });
    }
    async handleBackendExtensionsInstall(workingPath, functionLanguage) {
        await errors_1.runWithErrorCatchAndThrow(new error_1.InstallTeamsFxBindingError(), async () => await steps_1.step(steps_1.StepGroup.PreDeployStepGroup, steps_1.PreDeploySteps.installTeamsfxBinding, async () => {
            try {
                await deploy_1.FunctionDeploy.installFuncExtensions(workingPath, functionLanguage);
            }
            catch (error) {
                // wrap the original error to UserError so the extensibility model will pop-up a dialog correctly
                throw funcHelper_1.funcDepsHelper.transferError(error);
            }
        }));
    }
    async deploy(ctx, inputs, envInfo, tokenProvider) {
        await steps_1.StepHelperFactory.preDeployStepHelper.start(Object.entries(steps_1.PreDeploySteps).length, ctx.userInteraction);
        //PreDeploy
        await this.syncConfigFromContext(ctx, inputs, envInfo);
        const workingPath = this.getFunctionProjectRootPath(inputs.projectPath);
        const functionLanguage = this.checkAndGet(this.config.functionLanguage, enums_1.FunctionConfigKey.functionLanguage);
        const updated = await deploy_1.FunctionDeploy.hasUpdatedContent(workingPath, functionLanguage, envInfo.envName);
        if (!updated) {
            ctx.logProvider.info(message_1.InfoMessages.noChange);
            this.config.skipDeploy = true;
        }
        else {
            // NOTE: make sure this step is before using `dotnet` command if you refactor this code.
            await this.handleDotnetChecker(inputs);
            await this.handleBackendExtensionsInstall(workingPath, functionLanguage);
            await errors_1.runWithErrorCatchAndThrow(new error_1.InstallNpmPackageError(), async () => await steps_1.step(steps_1.StepGroup.PreDeployStepGroup, steps_1.PreDeploySteps.npmPrepare, async () => deploy_1.FunctionDeploy.build(workingPath, functionLanguage)));
            this.config.skipDeploy = false;
        }
        await steps_1.StepHelperFactory.preDeployStepHelper.end(true);
        await steps_1.StepHelperFactory.deployStepHelper.start(Object.entries(steps_1.DeploySteps).length, ctx.userInteraction);
        if (this.config.skipDeploy) {
            telemetry_helper_1.TelemetryHelper.sendGeneralEvent(enums_1.FunctionEvent.skipDeploy);
            ctx.logProvider.warning(message_1.InfoMessages.skipDeployment);
        }
        else {
            const workingPath = this.getFunctionProjectRootPath(inputs.projectPath);
            const functionAppName = this.getFunctionAppName();
            const resourceGroupName = this.getFunctionAppResourceGroupName();
            const subscriptionId = this.getFunctionAppSubscriptionId();
            const functionLanguage = this.checkAndGet(this.config.functionLanguage, enums_1.FunctionConfigKey.functionLanguage);
            const credential = this.checkAndGet(await tokenProvider.azureAccountProvider.getAccountCredentialAsync(), enums_1.FunctionConfigKey.credential);
            const webSiteManagementClient = await errors_1.runWithErrorCatchAndThrow(new error_1.InitAzureSDKError(), () => azure_client_1.AzureClientFactory.getWebSiteManagementClient(credential, subscriptionId));
            ctx.logProvider.debug(`deploy function with subscription id: ${subscriptionId}, resourceGroup name: ${resourceGroupName}, function web app name: ${functionAppName}`);
            await deploy_1.FunctionDeploy.deployFunction(webSiteManagementClient, workingPath, functionAppName, functionLanguage, resourceGroupName, envInfo.envName);
        }
        await steps_1.StepHelperFactory.deployStepHelper.end(true);
        return teamsfx_api_1.ok(teamsfx_api_1.Void);
    }
};
tslib_1.__decorate([
    lib_1.hooks([CommonErrorHandlerMW_1.CommonErrorHandlerMW({ telemetry: { component: constants_2.BuiltInFeaturePluginNames.function } })]),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [Object, Object]),
    tslib_1.__metadata("design:returntype", Promise)
], FunctionPluginV3.prototype, "generateCode", null);
tslib_1.__decorate([
    lib_1.hooks([CommonErrorHandlerMW_1.CommonErrorHandlerMW({ telemetry: { component: constants_2.BuiltInFeaturePluginNames.function } })]),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [Object, Object]),
    tslib_1.__metadata("design:returntype", Promise)
], FunctionPluginV3.prototype, "generateBicep", null);
tslib_1.__decorate([
    lib_1.hooks([CommonErrorHandlerMW_1.CommonErrorHandlerMW({ telemetry: { component: constants_2.BuiltInFeaturePluginNames.function } })]),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [Object, Object]),
    tslib_1.__metadata("design:returntype", Promise)
], FunctionPluginV3.prototype, "updateBicep", null);
tslib_1.__decorate([
    lib_1.hooks([CommonErrorHandlerMW_1.CommonErrorHandlerMW({ telemetry: { component: constants_2.BuiltInFeaturePluginNames.function } })]),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [Object, Object]),
    tslib_1.__metadata("design:returntype", Promise)
], FunctionPluginV3.prototype, "addInstance", null);
tslib_1.__decorate([
    lib_1.hooks([CommonErrorHandlerMW_1.CommonErrorHandlerMW({ telemetry: { component: constants_2.BuiltInFeaturePluginNames.function } })]),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [Object, Object, Object, Object]),
    tslib_1.__metadata("design:returntype", Promise)
], FunctionPluginV3.prototype, "configureResource", null);
tslib_1.__decorate([
    lib_1.hooks([CommonErrorHandlerMW_1.CommonErrorHandlerMW({ telemetry: { component: constants_2.BuiltInFeaturePluginNames.function } })]),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [Object, Object, Object, Object]),
    tslib_1.__metadata("design:returntype", Promise)
], FunctionPluginV3.prototype, "deploy", null);
FunctionPluginV3 = tslib_1.__decorate([
    typedi_1.Service(constants_2.BuiltInFeaturePluginNames.function)
], FunctionPluginV3);
exports.FunctionPluginV3 = FunctionPluginV3;
//# sourceMappingURL=index.js.map