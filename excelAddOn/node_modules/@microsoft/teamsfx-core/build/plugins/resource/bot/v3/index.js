"use strict";
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", { value: true });
exports.NodeJSBotPluginV3 = void 0;
const tslib_1 = require("tslib");
const hooks_1 = require("@feathersjs/hooks");
const teamsfx_api_1 = require("@microsoft/teamsfx-api");
const path = tslib_1.__importStar(require("path"));
const typedi_1 = require("typedi");
const constants_1 = require("../../../../common/constants");
const tools_1 = require("../../../../common/tools");
const CommonErrorHandlerMW_1 = require("../../../../core/middleware/CommonErrorHandlerMW");
const folder_1 = require("../../../../folder");
const question_1 = require("../../../solution/fx-solution/question");
const constants_2 = require("../../../solution/fx-solution/v3/constants");
const constants_3 = require("../constants");
const languageStrategy_1 = require("../languageStrategy");
const progressBars_1 = require("../progressBars");
const messages_1 = require("../resources/messages");
const fs_extra_1 = tslib_1.__importDefault(require("fs-extra"));
const strings_1 = require("../resources/strings");
const factory = tslib_1.__importStar(require("../clientFactory"));
const resourceNameFactory_1 = require("../utils/resourceNameFactory");
const aadRegistration_1 = require("../aadRegistration");
const appStudio_1 = require("../appStudio/appStudio");
const deployMgr_1 = require("../deployMgr");
const utils = tslib_1.__importStar(require("../utils/common"));
const appService = tslib_1.__importStar(require("@azure/arm-appservice"));
const zipDeploy_1 = require("../utils/zipDeploy");
const templatesActions_1 = require("../../../../common/template-utils/templatesActions");
const programmingLanguage_1 = require("../enums/programmingLanguage");
const error_1 = require("./error");
const solutionSettingsHelper_1 = require("../../../solution/fx-solution/utils/solutionSettingsHelper");
const azureOps_1 = require("../../../../common/azure-hosting/azureOps");
const utils_1 = require("../../../../common/utils");
let NodeJSBotPluginV3 = class NodeJSBotPluginV3 {
    constructor() {
        this.name = constants_2.BuiltInFeaturePluginNames.bot;
        this.displayName = "NodeJS Bot";
    }
    getProgrammingLanguage(ctx) {
        const rawProgrammingLanguage = ctx.projectSetting.programmingLanguage;
        if (rawProgrammingLanguage &&
            utils.existsInEnumValues(rawProgrammingLanguage, programmingLanguage_1.ProgrammingLanguage)) {
            return rawProgrammingLanguage;
        }
        return programmingLanguage_1.ProgrammingLanguage.JavaScript;
    }
    getLangKey(ctx) {
        const rawProgrammingLanguage = ctx.projectSetting.programmingLanguage;
        if (rawProgrammingLanguage &&
            utils.existsInEnumValues(rawProgrammingLanguage, programmingLanguage_1.ProgrammingLanguage)) {
            const programmingLanguage = rawProgrammingLanguage;
            return utils.convertToLangKey(programmingLanguage);
        }
        return "js";
    }
    async generateCode(ctx, inputs) {
        ctx.logProvider.info(messages_1.Messages.ScaffoldingBot);
        const solutionSettings = ctx.projectSetting.solutionSettings;
        if (solutionSettings.activeResourcePlugins.includes(this.name))
            return teamsfx_api_1.ok(teamsfx_api_1.Void);
        const handler = await progressBars_1.ProgressBarFactory.newProgressBar(constants_3.ProgressBarConstants.SCAFFOLD_TITLE, constants_3.ProgressBarConstants.SCAFFOLD_STEPS_NUM, ctx);
        await (handler === null || handler === void 0 ? void 0 : handler.start(constants_3.ProgressBarConstants.SCAFFOLD_STEP_START));
        const group_name = constants_3.TemplateProjectsConstants.GROUP_NAME_BOT_MSGEXT;
        const lang = this.getLangKey(ctx);
        const workingDir = path.join(inputs.projectPath, strings_1.CommonStrings.BOT_WORKING_DIR_NAME);
        await (handler === null || handler === void 0 ? void 0 : handler.next(constants_3.ProgressBarConstants.SCAFFOLD_STEP_FETCH_ZIP));
        await templatesActions_1.scaffoldFromTemplates({
            group: group_name,
            lang: lang,
            scenario: constants_3.TemplateProjectsScenarios.DEFAULT_SCENARIO_NAME,
            dst: workingDir,
            onActionEnd: async (action, context) => {
                var _a;
                if (action.name === templatesActions_1.ScaffoldActionName.FetchTemplatesUrlWithTag) {
                    ctx.logProvider.info(messages_1.Messages.SuccessfullyRetrievedTemplateZip((_a = context.zipUrl) !== null && _a !== void 0 ? _a : ""));
                }
            },
            onActionError: async (action, context, error) => {
                ctx.logProvider.info(error.toString());
                switch (action.name) {
                    case templatesActions_1.ScaffoldActionName.FetchTemplatesUrlWithTag:
                    case templatesActions_1.ScaffoldActionName.FetchTemplatesZipFromUrl:
                        ctx.logProvider.info(messages_1.Messages.FallingBackToUseLocalTemplateZip);
                        break;
                    case templatesActions_1.ScaffoldActionName.FetchTemplateZipFromLocal:
                        throw new error_1.TemplateZipFallbackError();
                    case templatesActions_1.ScaffoldActionName.Unzip:
                        throw new error_1.UnzipError(context.dst);
                    default:
                        throw new Error(error.message);
                }
            },
        });
        ctx.logProvider.info(messages_1.Messages.SuccessfullyScaffoldedBot);
        handler === null || handler === void 0 ? void 0 : handler.end(true);
        return teamsfx_api_1.ok(teamsfx_api_1.Void);
    }
    async generateBicep(ctx, inputs) {
        const solutionSettings = ctx.projectSetting.solutionSettings;
        if (solutionSettings.activeResourcePlugins.includes(this.name))
            return teamsfx_api_1.ok([]);
        const pluginCtx = { plugins: inputs.allPluginsAfterAdd };
        const bicepTemplateDir = path.join(folder_1.getTemplatesFolder(), constants_3.PathInfo.BicepTemplateRelativeDir);
        const provisionOrchestration = await tools_1.generateBicepFromFile(path.join(bicepTemplateDir, constants_1.Bicep.ProvisionFileName), pluginCtx);
        const provisionModules = await tools_1.generateBicepFromFile(path.join(bicepTemplateDir, constants_3.PathInfo.ProvisionModuleTemplateFileName), pluginCtx);
        const configOrchestration = await tools_1.generateBicepFromFile(path.join(bicepTemplateDir, constants_1.Bicep.ConfigFileName), pluginCtx);
        const configModule = await tools_1.generateBicepFromFile(path.join(bicepTemplateDir, constants_3.PathInfo.ConfigurationModuleTemplateFileName), pluginCtx);
        const result = {
            Provision: {
                Orchestration: provisionOrchestration,
                Modules: { bot: provisionModules },
            },
            Configuration: {
                Orchestration: configOrchestration,
                Modules: { bot: configModule },
            },
            Reference: {
                resourceId: constants_3.BotBicep.resourceId,
                hostName: constants_3.BotBicep.hostName,
                webAppEndpoint: constants_3.BotBicep.webAppEndpoint,
            },
            Parameters: JSON.parse(await fs_extra_1.default.readFile(path.join(bicepTemplateDir, constants_1.Bicep.ParameterFileName), constants_1.ConstantString.UTF8Encoding)),
        };
        return teamsfx_api_1.ok([result]);
    }
    async getQuestionsForAddInstance(ctx, inputs) {
        const capabilitiesQuestion = {
            name: question_1.AzureSolutionQuestionNames.Capabilities,
            title: "Select capabilities",
            type: "multiSelect",
            staticOptions: [question_1.BotOptionItem, question_1.MessageExtensionItem],
            default: [question_1.BotOptionItem.id],
            placeholder: "Select at least 1 capability",
            validation: {
                minItems: 1,
            },
        };
        return teamsfx_api_1.ok(new teamsfx_api_1.QTreeNode(capabilitiesQuestion));
    }
    async addInstance(ctx, inputs) {
        solutionSettingsHelper_1.ensureSolutionSettings(ctx.projectSetting);
        const solutionSettings = ctx.projectSetting.solutionSettings;
        const capabilities = solutionSettings.capabilities;
        const newCapabilitySet = new Set();
        capabilities.forEach((c) => newCapabilitySet.add(c));
        const activeResourcePlugins = solutionSettings.activeResourcePlugins;
        const capabilitiesToAddManifest = [];
        const capabilitiesAnswer = inputs[question_1.AzureSolutionQuestionNames.Capabilities];
        if (capabilitiesAnswer.includes(question_1.BotOptionItem.id)) {
            capabilitiesToAddManifest.push({ name: "Bot" });
            newCapabilitySet.add(question_1.BotOptionItem.id);
        }
        if (capabilitiesAnswer.includes(question_1.MessageExtensionItem.id)) {
            capabilitiesToAddManifest.push({ name: "MessageExtension" });
            newCapabilitySet.add(question_1.MessageExtensionItem.id);
        }
        const update = await ctx.appManifestProvider.addCapabilities(ctx, inputs, capabilitiesToAddManifest);
        if (update.isErr())
            return teamsfx_api_1.err(update.error);
        solutionSettings.capabilities = Array.from(newCapabilitySet);
        if (!activeResourcePlugins.includes(this.name))
            activeResourcePlugins.push(this.name);
        return teamsfx_api_1.ok([constants_2.BuiltInFeaturePluginNames.identity]);
    }
    async updateBicep(ctx, inputs) {
        const pluginCtx = { plugins: inputs.allPluginsAfterAdd };
        const bicepTemplateDir = path.join(folder_1.getTemplatesFolder(), constants_3.PathInfo.BicepTemplateRelativeDir);
        const configModule = await tools_1.generateBicepFromFile(path.join(bicepTemplateDir, constants_3.PathInfo.ConfigurationModuleTemplateFileName), pluginCtx);
        const result = {
            Reference: {
                resourceId: constants_3.BotBicep.resourceId,
                hostName: constants_3.BotBicep.hostName,
                webAppEndpoint: constants_3.BotBicep.webAppEndpoint,
            },
            Configuration: {
                Modules: { bot: configModule },
            },
        };
        return teamsfx_api_1.ok([result]);
    }
    async getAzureAccountCredential(tokenProvider) {
        const serviceClientCredentials = await tokenProvider.getAccountCredentialAsync();
        if (!serviceClientCredentials) {
            throw new error_1.PreconditionError(messages_1.Messages.FailToGetAzureCreds, [messages_1.Messages.TryLoginAzure]);
        }
        return serviceClientCredentials;
    }
    async createOrGetBotAppRegistration(ctx, envInfo, tokenProvider) {
        const graphTokenRes = await tokenProvider.m365TokenProvider.getAccessToken({
            scopes: tools_1.GraphScopes,
        });
        const token = graphTokenRes.isOk() ? graphTokenRes.value : undefined;
        error_1.CheckThrowSomethingMissing(strings_1.ConfigNames.GRAPH_TOKEN, token);
        error_1.CheckThrowSomethingMissing(strings_1.CommonStrings.SHORT_APP_NAME, ctx.projectSetting.appName);
        let botConfig = envInfo.state[this.name];
        if (!botConfig)
            botConfig = {};
        botConfig = botConfig;
        const botAADCreated = (botConfig === null || botConfig === void 0 ? void 0 : botConfig.botId) !== undefined && (botConfig === null || botConfig === void 0 ? void 0 : botConfig.botPassword) !== undefined;
        if (!botAADCreated) {
            const solutionConfig = envInfo === null || envInfo === void 0 ? void 0 : envInfo.state.solution;
            const resourceNameSuffix = solutionConfig.resourceNameSuffix
                ? solutionConfig.resourceNameSuffix
                : utils.genUUID();
            const aadDisplayName = resourceNameFactory_1.ResourceNameFactory.createCommonName(resourceNameSuffix, ctx.projectSetting.appName, constants_3.MaxLengths.AAD_DISPLAY_NAME);
            const botAuthCreds = await aadRegistration_1.AADRegistration.registerAADAppAndGetSecretByGraph(token, aadDisplayName, botConfig.objectId, botConfig.botId);
            botConfig.botId = botAuthCreds.clientId;
            botConfig.botPassword = botAuthCreds.clientSecret;
            botConfig.objectId = botAuthCreds.objectId;
            ctx.logProvider.info(messages_1.Messages.SuccessfullyCreatedBotAadApp);
        }
        if (envInfo.envName === "local") {
            // 2. Register bot by app studio.
            const botReg = {
                botId: botConfig.botId,
                name: utils_1.convertToAlphanumericOnly(ctx.projectSetting.appName) +
                    strings_1.PluginLocalDebug.LOCAL_DEBUG_SUFFIX,
                description: "",
                iconUrl: "",
                messagingEndpoint: "",
                callingEndpoint: "",
            };
            ctx.logProvider.info(messages_1.Messages.ProvisioningBotRegistration);
            const appStudioTokenRes = await tokenProvider.m365TokenProvider.getAccessToken({
                scopes: tools_1.AppStudioScopes,
            });
            const appStudioToken = appStudioTokenRes.isOk() ? appStudioTokenRes.value : undefined;
            error_1.CheckThrowSomethingMissing(strings_1.ConfigNames.APPSTUDIO_TOKEN, appStudioToken);
            await appStudio_1.AppStudio.createBotRegistration(appStudioToken, botReg);
            ctx.logProvider.info(messages_1.Messages.SuccessfullyProvisionedBotRegistration);
        }
        return teamsfx_api_1.ok(teamsfx_api_1.Void);
    }
    async provisionResource(ctx, inputs, envInfo, tokenProvider) {
        const botState = envInfo.state[this.name];
        if (!botState.secretFields)
            botState.secretFields = ["botPassword"];
        if (envInfo.envName === "local") {
            const handler = await progressBars_1.ProgressBarFactory.newProgressBar(constants_3.ProgressBarConstants.LOCAL_DEBUG_TITLE, constants_3.ProgressBarConstants.LOCAL_DEBUG_STEPS_NUM, ctx);
            await (handler === null || handler === void 0 ? void 0 : handler.start(constants_3.ProgressBarConstants.LOCAL_DEBUG_STEP_START));
            await (handler === null || handler === void 0 ? void 0 : handler.next(constants_3.ProgressBarConstants.LOCAL_DEBUG_STEP_BOT_REG));
            await this.createOrGetBotAppRegistration(ctx, envInfo, tokenProvider);
            await (handler === null || handler === void 0 ? void 0 : handler.end(true));
        }
        else {
            ctx.logProvider.info(messages_1.Messages.ProvisioningBot);
            // Create and register progress bar for cleanup.
            const handler = await progressBars_1.ProgressBarFactory.newProgressBar(constants_3.ProgressBarConstants.PROVISION_TITLE, 1, ctx);
            await (handler === null || handler === void 0 ? void 0 : handler.start(constants_3.ProgressBarConstants.PROVISION_STEP_START));
            // 0. Check Resource Provider
            const azureCredential = await this.getAzureAccountCredential(tokenProvider.azureAccountProvider);
            const solutionConfig = envInfo.state.solution;
            const rpClient = factory.createResourceProviderClient(azureCredential, solutionConfig.subscriptionId);
            await factory.ensureResourceProvider(rpClient, constants_3.AzureConstants.requiredResourceProviders);
            // 1. Do bot registration.
            await (handler === null || handler === void 0 ? void 0 : handler.next(constants_3.ProgressBarConstants.PROVISION_STEP_BOT_REG));
            await this.createOrGetBotAppRegistration(ctx, envInfo, tokenProvider);
            await (handler === null || handler === void 0 ? void 0 : handler.end(true));
        }
        return teamsfx_api_1.ok(teamsfx_api_1.Void);
    }
    async updateMessageEndpointOnAppStudio(tokenProvider, botId, endpoint) {
        const appStudioTokenRes = await tokenProvider.m365TokenProvider.getAccessToken({
            scopes: tools_1.AppStudioScopes,
        });
        const appStudioToken = appStudioTokenRes.isOk() ? appStudioTokenRes.value : undefined;
        error_1.CheckThrowSomethingMissing(strings_1.ConfigNames.APPSTUDIO_TOKEN, appStudioToken);
        error_1.CheckThrowSomethingMissing(strings_1.ConfigNames.LOCAL_BOT_ID, botId);
        await appStudio_1.AppStudio.updateMessageEndpoint(appStudioToken, botId, endpoint);
    }
    async configureResource(ctx, inputs, envInfo, tokenProvider) {
        if (envInfo.envName === "local") {
            const botConfig = envInfo.state[this.name];
            error_1.CheckThrowSomethingMissing(strings_1.ConfigNames.LOCAL_ENDPOINT, botConfig.siteEndpoint);
            await this.updateMessageEndpointOnAppStudio(tokenProvider, botConfig.botId, `${botConfig.siteEndpoint}${strings_1.CommonStrings.MESSAGE_ENDPOINT_SUFFIX}`);
        }
        return teamsfx_api_1.ok(teamsfx_api_1.Void);
    }
    async deploy(ctx, inputs, envInfo, tokenProvider) {
        var _a, _b, _c;
        ctx.logProvider.info(messages_1.Messages.PreDeployingBot);
        // Preconditions checking.
        const workingDir = path.join(inputs.projectPath, strings_1.CommonStrings.BOT_WORKING_DIR_NAME);
        if (!workingDir) {
            throw new error_1.PreconditionError(messages_1.Messages.WorkingDirIsMissing, []);
        }
        const packDirExisted = await fs_extra_1.default.pathExists(workingDir);
        if (!packDirExisted) {
            throw new error_1.PackDirectoryExistenceError();
        }
        const botConfig = envInfo.state[this.name];
        const programmingLanguage = this.getProgrammingLanguage(ctx);
        error_1.CheckThrowSomethingMissing(strings_1.ConfigNames.SITE_ENDPOINT, botConfig.siteEndpoint);
        error_1.CheckThrowSomethingMissing(strings_1.ConfigNames.PROGRAMMING_LANGUAGE, programmingLanguage);
        error_1.CheckThrowSomethingMissing(strings_1.ConfigNames.BOT_SERVICE_RESOURCE_ID, botConfig.botWebAppResourceId);
        const subscriptionId = tools_1.getSubscriptionIdFromResourceId(botConfig.botWebAppResourceId);
        const resourceGroup = tools_1.getResourceGroupNameFromResourceId(botConfig.botWebAppResourceId);
        const siteName = tools_1.getSiteNameFromResourceId(botConfig.botWebAppResourceId);
        error_1.CheckThrowSomethingMissing(strings_1.ConfigNames.SUBSCRIPTION_ID, subscriptionId);
        error_1.CheckThrowSomethingMissing(strings_1.ConfigNames.RESOURCE_GROUP, resourceGroup);
        ctx.logProvider.info(messages_1.Messages.DeployingBot);
        const deployTimeCandidate = Date.now();
        const deployMgr = new deployMgr_1.DeployMgr(workingDir, envInfo.envName);
        await deployMgr.init();
        if (!(await deployMgr.needsToRedeploy())) {
            ctx.logProvider.debug(messages_1.Messages.SkipDeployNoUpdates);
            return teamsfx_api_1.ok(teamsfx_api_1.Void);
        }
        const handler = await progressBars_1.ProgressBarFactory.newProgressBar(constants_3.ProgressBarConstants.DEPLOY_TITLE, constants_3.ProgressBarConstants.DEPLOY_STEPS_NUM, ctx);
        await (handler === null || handler === void 0 ? void 0 : handler.start(constants_3.ProgressBarConstants.DEPLOY_STEP_START));
        await (handler === null || handler === void 0 ? void 0 : handler.next(constants_3.ProgressBarConstants.DEPLOY_STEP_NPM_INSTALL));
        const unPackFlag = (_a = envInfo.config.bot) === null || _a === void 0 ? void 0 : _a.unPackFlag;
        await languageStrategy_1.LanguageStrategy.localBuild(programmingLanguage, workingDir, unPackFlag === "false" ? false : true);
        await (handler === null || handler === void 0 ? void 0 : handler.next(constants_3.ProgressBarConstants.DEPLOY_STEP_ZIP_FOLDER));
        const zipBuffer = utils.zipAFolder(workingDir, constants_3.DeployConfigs.UN_PACK_DIRS, [
            `${constants_3.FolderNames.NODE_MODULES}/${constants_3.FolderNames.KEYTAR}`,
        ]);
        // 2.2 Retrieve publishing credentials.
        const webSiteMgmtClient = new appService.WebSiteManagementClient(await this.getAzureAccountCredential(tokenProvider.azureAccountProvider), subscriptionId);
        const listResponse = await azureOps_1.AzureOperations.listPublishingCredentials(webSiteMgmtClient, resourceGroup, siteName);
        const publishingUserName = (_b = listResponse.publishingUserName) !== null && _b !== void 0 ? _b : "";
        const publishingPassword = (_c = listResponse.publishingPassword) !== null && _c !== void 0 ? _c : "";
        const encryptedCreds = utils.toBase64(`${publishingUserName}:${publishingPassword}`);
        const config = {
            headers: {
                Authorization: `Basic ${encryptedCreds}`,
            },
            maxContentLength: Infinity,
            maxBodyLength: Infinity,
        };
        const zipDeployEndpoint = zipDeploy_1.getZipDeployEndpoint(botConfig.siteName);
        await (handler === null || handler === void 0 ? void 0 : handler.next(constants_3.ProgressBarConstants.DEPLOY_STEP_ZIP_DEPLOY));
        const statusUrl = await azureOps_1.AzureOperations.zipDeployPackage(zipDeployEndpoint, zipBuffer, config);
        await azureOps_1.AzureOperations.checkDeployStatus(statusUrl, config);
        await deployMgr.updateLastDeployTime(deployTimeCandidate);
        await (handler === null || handler === void 0 ? void 0 : handler.end(true));
        ctx.logProvider.info(messages_1.Messages.SuccessfullyDeployedBot);
        return teamsfx_api_1.ok(teamsfx_api_1.Void);
    }
};
tslib_1.__decorate([
    hooks_1.hooks([CommonErrorHandlerMW_1.CommonErrorHandlerMW({ telemetry: { component: constants_2.BuiltInFeaturePluginNames.bot } })]),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [Object, Object]),
    tslib_1.__metadata("design:returntype", Promise)
], NodeJSBotPluginV3.prototype, "generateCode", null);
tslib_1.__decorate([
    hooks_1.hooks([CommonErrorHandlerMW_1.CommonErrorHandlerMW({ telemetry: { component: constants_2.BuiltInFeaturePluginNames.bot } })]),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [Object, Object]),
    tslib_1.__metadata("design:returntype", Promise)
], NodeJSBotPluginV3.prototype, "generateBicep", null);
tslib_1.__decorate([
    hooks_1.hooks([CommonErrorHandlerMW_1.CommonErrorHandlerMW({ telemetry: { component: constants_2.BuiltInFeaturePluginNames.bot } })]),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [Object, Object]),
    tslib_1.__metadata("design:returntype", Promise)
], NodeJSBotPluginV3.prototype, "addInstance", null);
tslib_1.__decorate([
    hooks_1.hooks([CommonErrorHandlerMW_1.CommonErrorHandlerMW({ telemetry: { component: constants_2.BuiltInFeaturePluginNames.bot } })]),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [Object, Object]),
    tslib_1.__metadata("design:returntype", Promise)
], NodeJSBotPluginV3.prototype, "updateBicep", null);
tslib_1.__decorate([
    hooks_1.hooks([CommonErrorHandlerMW_1.CommonErrorHandlerMW({ telemetry: { component: constants_2.BuiltInFeaturePluginNames.bot } })]),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [Object, Object, Object, Object]),
    tslib_1.__metadata("design:returntype", Promise)
], NodeJSBotPluginV3.prototype, "provisionResource", null);
tslib_1.__decorate([
    hooks_1.hooks([CommonErrorHandlerMW_1.CommonErrorHandlerMW({ telemetry: { component: constants_2.BuiltInFeaturePluginNames.bot } })]),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [Object, Object, Object, Object]),
    tslib_1.__metadata("design:returntype", Promise)
], NodeJSBotPluginV3.prototype, "configureResource", null);
tslib_1.__decorate([
    hooks_1.hooks([CommonErrorHandlerMW_1.CommonErrorHandlerMW({ telemetry: { component: constants_2.BuiltInFeaturePluginNames.bot } })]),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [Object, Object, Object, Object]),
    tslib_1.__metadata("design:returntype", Promise)
], NodeJSBotPluginV3.prototype, "deploy", null);
NodeJSBotPluginV3 = tslib_1.__decorate([
    typedi_1.Service(constants_2.BuiltInFeaturePluginNames.bot)
], NodeJSBotPluginV3);
exports.NodeJSBotPluginV3 = NodeJSBotPluginV3;
//# sourceMappingURL=index.js.map