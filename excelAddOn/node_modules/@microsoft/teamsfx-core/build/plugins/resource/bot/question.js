"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getConditionOfNotificationTriggerQuestion = exports.showNotificationTriggerCondition = exports.createHostTypeTriggerQuestion = exports.FunctionsOptionItems = exports.AppServiceOptionItemForVS = exports.AppServiceOptionItem = exports.FunctionsHttpTriggerOptionItem = exports.FunctionsTimerTriggerOptionItem = void 0;
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
const teamsfx_api_1 = require("@microsoft/teamsfx-api");
const featureFlags_1 = require("../../../common/featureFlags");
const localizeUtils_1 = require("../../../common/localizeUtils");
const question_1 = require("../../../core/question");
const question_2 = require("../../solution/fx-solution/question");
const constants_1 = require("./constants");
const strings_1 = require("./resources/strings");
const enum_1 = require("./v2/enum");
// NOTE: id must be the sample as cliName to prevent parsing error for CLI default value.
exports.FunctionsTimerTriggerOptionItem = optionWithL10n({
    id: "timer-functions",
    hostType: enum_1.HostType.Functions,
    trigger: strings_1.NotificationTriggers.TIMER,
});
exports.FunctionsHttpTriggerOptionItem = optionWithL10n({
    id: "http-functions",
    hostType: enum_1.HostType.Functions,
    trigger: strings_1.NotificationTriggers.HTTP,
});
exports.AppServiceOptionItem = optionWithL10n({
    id: "http-restify",
    hostType: enum_1.HostType.AppService,
    // trigger of app service host is hard-coded to http, so no need to set here
});
// TODO: this option will not be shown in UI, leave messages empty.
exports.AppServiceOptionItemForVS = optionWithL10n({
    id: "http-webapi",
    hostType: enum_1.HostType.AppService,
});
exports.FunctionsOptionItems = [
    exports.FunctionsHttpTriggerOptionItem,
    exports.FunctionsTimerTriggerOptionItem,
];
// The restrictions of this question:
//   - appService and function are mutually exclusive
//   - users must select at least one trigger.
function createHostTypeTriggerQuestion(platform, runtime) {
    const prefix = "plugins.bot.questionHostTypeTrigger";
    const defaultOptionItem = runtime === enum_1.Runtime.Dotnet ? exports.AppServiceOptionItemForVS : exports.AppServiceOptionItem;
    let staticOptions = [defaultOptionItem, ...exports.FunctionsOptionItems];
    if (platform === teamsfx_api_1.Platform.CLI) {
        // The UI in CLI is different. It does not have description. So we need to merge that into label.
        staticOptions = staticOptions.map((option) => {
            // do not change the original option
            const cliOption = Object.assign({}, option);
            cliOption.label = `${option.label} (${option.description})`;
            return cliOption;
        });
    }
    return {
        name: constants_1.QuestionNames.BOT_HOST_TYPE_TRIGGER,
        title: localizeUtils_1.getLocalizedString(`${prefix}.title`),
        type: "multiSelect",
        staticOptions: staticOptions,
        default: [defaultOptionItem.id],
        placeholder: localizeUtils_1.getLocalizedString(`${prefix}.placeholder`),
        validation: {
            validFunc: async (input) => {
                const name = input;
                if (name.length === 0) {
                    return localizeUtils_1.getLocalizedString(`${prefix}.error.emptySelection`);
                }
                //invalid if both appService and function items are selected
                if (name.includes(defaultOptionItem.id) && name.length > 1) {
                    return localizeUtils_1.getLocalizedString(`${prefix}.error.hostTypeConflict`);
                }
                return undefined;
            },
        },
        onDidChangeSelection: async function (currentSelectedIds, previousSelectedIds) {
            return question_1.handleSelectionConflict([
                new Set([defaultOptionItem.id]),
                new Set([exports.FunctionsHttpTriggerOptionItem.id, exports.FunctionsTimerTriggerOptionItem.id]),
            ], previousSelectedIds, currentSelectedIds);
        },
    };
}
exports.createHostTypeTriggerQuestion = createHostTypeTriggerQuestion;
// Question model condition to determine whether to show "Select triggers" question after "Select capabilities".
// Return undefined for true, a string for false. The string itself it not used.
exports.showNotificationTriggerCondition = {
    validFunc: (input, inputs) => {
        if (!inputs) {
            return "Invalid inputs";
        }
        if (featureFlags_1.isPreviewFeaturesEnabled()) {
            const cap = inputs[question_2.AzureSolutionQuestionNames.Capabilities];
            if (cap === question_2.NotificationOptionItem.id) {
                return undefined;
            }
            // Single Select Option for "Add Feature"
            const feature = inputs[question_2.AzureSolutionQuestionNames.Features];
            if (feature === question_2.NotificationOptionItem.id) {
                return undefined;
            }
        }
        else {
            const cap = inputs[question_2.AzureSolutionQuestionNames.Capabilities];
            if (Array.isArray(cap) && cap.includes(question_2.NotificationOptionItem.id)) {
                return undefined;
            }
        }
        return "Notification is not selected";
    },
    // Workaround for CLI: it requires containsAny to be set, or it will crash.
    containsAny: [question_2.NotificationOptionItem.id],
};
function getConditionOfNotificationTriggerQuestion(runtime) {
    return {
        validFunc: async (input, inputs) => {
            if ((inputs === null || inputs === void 0 ? void 0 : inputs[question_1.CoreQuestionNames.Runtime]) === runtime) {
                return undefined;
            }
            else {
                return `runtime is not ${runtime}`;
            }
        },
    };
}
exports.getConditionOfNotificationTriggerQuestion = getConditionOfNotificationTriggerQuestion;
function optionWithL10n(option) {
    // e.g. expands to plugins.bot.triggers.functionsTimer.label
    const prefix = "plugins.bot.triggers";
    return Object.assign(Object.assign({}, option), { label: localizeUtils_1.getLocalizedString(`${prefix}.${option.id}.label`), cliName: localizeUtils_1.getLocalizedString(`${prefix}.${option.id}.cliName`), description: localizeUtils_1.getLocalizedString(`${prefix}.${option.id}.description`), detail: localizeUtils_1.getLocalizedString(`${prefix}.${option.id}.detail`) });
}
//# sourceMappingURL=question.js.map