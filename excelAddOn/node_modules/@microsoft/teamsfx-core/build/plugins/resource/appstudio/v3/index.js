"use strict";
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", { value: true });
exports.AppStudioPluginV3 = void 0;
const tslib_1 = require("tslib");
const teamsfx_api_1 = require("@microsoft/teamsfx-api");
const typedi_1 = require("typedi");
const constants_1 = require("../../../solution/fx-solution/v3/constants");
const utils4v2_1 = require("../../utils4v2");
const results_1 = require("../results");
const errors_1 = require("../errors");
const manifestTemplate_1 = require("../manifestTemplate");
const folder_1 = require("../../../../folder");
const path = tslib_1.__importStar(require("path"));
const fs_extra_1 = tslib_1.__importDefault(require("fs-extra"));
const constants_2 = require("../constants");
const telemetry_1 = require("../utils/telemetry");
const isUUID_1 = tslib_1.__importDefault(require("validator/lib/isUUID"));
const appStudio_1 = require("../appStudio");
const projectSettingsHelper_1 = require("../../../../common/projectSettingsHelper");
const common_1 = require("../../../../common");
const appStudio_2 = require("../../../../component/resource/appManifest/appStudio");
const utils_1 = require("../../../../common/utils");
const constants_3 = require("../../../../component/constants");
let AppStudioPluginV3 = class AppStudioPluginV3 {
    constructor() {
        this.name = "fx-resource-appstudio";
        this.displayName = "App Studio";
    }
    /**
     * Generate initial manifest template file, for both local debug & remote
     * @param ctx
     * @param inputs
     * @returns
     */
    async init(ctx, inputs) {
        telemetry_1.TelemetryUtils.init(ctx);
        telemetry_1.TelemetryUtils.sendStartEvent(telemetry_1.TelemetryEventName.init);
        const res = await manifestTemplate_1.init(inputs.projectPath, ctx.projectSetting.appName, projectSettingsHelper_1.isExistingTabApp(ctx.projectSetting));
        if (res.isErr())
            return teamsfx_api_1.err(res.error);
        const templatesFolder = folder_1.getTemplatesFolder();
        const projectTemplatesFolderName = await utils_1.getProjectTemplatesFolderPath(inputs.projectPath);
        const defaultColorPath = path.join(templatesFolder, constants_2.COLOR_TEMPLATE);
        const defaultOutlinePath = path.join(templatesFolder, constants_2.OUTLINE_TEMPLATE);
        const appPackageDir = path.join(projectTemplatesFolderName, "appPackage");
        const resourcesDir = path.resolve(appPackageDir, constants_2.MANIFEST_RESOURCES);
        await fs_extra_1.default.ensureDir(resourcesDir);
        await fs_extra_1.default.copy(defaultColorPath, path.join(resourcesDir, constants_2.DEFAULT_COLOR_PNG_FILENAME));
        await fs_extra_1.default.copy(defaultOutlinePath, path.join(resourcesDir, constants_2.DEFAULT_OUTLINE_PNG_FILENAME));
        telemetry_1.TelemetryUtils.sendSuccessEvent(telemetry_1.TelemetryEventName.init);
        return teamsfx_api_1.ok(undefined);
    }
    /**
     * Check if manifest templates already exist.
     */
    async preCheck(projectPath) {
        const existFiles = new Array();
        for (const templates of ["Templates", "templates"]) {
            const appPackageDir = path.join(projectPath, templates, "appPackage");
            const manifestPath = path.resolve(appPackageDir, constants_2.TEAMS_APP_MANIFEST_TEMPLATE_V3);
            if (await fs_extra_1.default.pathExists(manifestPath)) {
                existFiles.push(manifestPath);
            }
            const resourcesDir = path.resolve(appPackageDir, constants_2.MANIFEST_RESOURCES);
            const defaultColorPath = path.join(resourcesDir, constants_2.DEFAULT_COLOR_PNG_FILENAME);
            if (await fs_extra_1.default.pathExists(defaultColorPath)) {
                existFiles.push(defaultColorPath);
            }
            const defaultOutlinePath = path.join(resourcesDir, constants_2.DEFAULT_OUTLINE_PNG_FILENAME);
            if (await fs_extra_1.default.pathExists(defaultOutlinePath)) {
                existFiles.push(defaultOutlinePath);
            }
        }
        return existFiles;
    }
    /**
     * Append capabilities to manifest templates
     * @param ctx
     * @param inputs
     * @param capabilities
     * @returns
     */
    async addCapabilities(ctx, inputs, capabilities) {
        telemetry_1.TelemetryUtils.init(ctx);
        telemetry_1.TelemetryUtils.sendStartEvent(telemetry_1.TelemetryEventName.addCapability);
        const pluginContext = utils4v2_1.convert2PluginContext(this.name, ctx, inputs);
        capabilities.map(async (capability) => {
            const exceedLimit = await this.capabilityExceedLimit(ctx, inputs, capability.name);
            if (exceedLimit.isErr()) {
                return teamsfx_api_1.err(exceedLimit.error);
            }
            if (exceedLimit.value) {
                return teamsfx_api_1.err(results_1.AppStudioResultFactory.UserError(errors_1.AppStudioError.CapabilityExceedLimitError.name, errors_1.AppStudioError.CapabilityExceedLimitError.message(capability.name)));
            }
        });
        const res = await manifestTemplate_1.addCapabilities(pluginContext.root, capabilities, inputs);
        if (res.isOk()) {
            telemetry_1.TelemetryUtils.sendSuccessEvent(telemetry_1.TelemetryEventName.addCapability);
        }
        else {
            telemetry_1.TelemetryUtils.sendErrorEvent(telemetry_1.TelemetryEventName.addCapability, res.error);
        }
        return res;
    }
    /**
     * Update existing manifest template
     * @param ctx
     * @param inputs
     * @param capability
     */
    async updateCapability(ctx, inputs, capability) {
        return await manifestTemplate_1.updateCapability(inputs.projectPath, capability);
    }
    /**
     * Delete existing manifest template
     * @param ctx
     * @param inputs
     * @param capability
     */
    async deleteCapability(ctx, inputs, capability) {
        return await manifestTemplate_1.deleteCapability(inputs.projectPath, capability);
    }
    /**
     * Load manifest template, and check if it exceeds the limit.
     * The limit of staticTab if 16, others are 1
     * Should check both local & remote manifest template file
     * @param capability
     * @returns
     */
    async capabilityExceedLimit(ctx, inputs, capability) {
        const pluginContext = utils4v2_1.convert2PluginContext(this.name, ctx, inputs);
        return await manifestTemplate_1.capabilityExceedLimit(pluginContext.root, capability);
    }
    async registerTeamsApp(ctx, inputs, envInfo, tokenProvider) {
        telemetry_1.TelemetryUtils.init(ctx);
        telemetry_1.TelemetryUtils.sendStartEvent(telemetry_1.TelemetryEventName.provisionManifest);
        const result = await appStudio_2.createTeamsApp(ctx, inputs, envInfo, tokenProvider);
        if (result.isOk()) {
            const properties = {};
            properties[telemetry_1.TelemetryPropertyKey.appId] = result.value;
            telemetry_1.TelemetryUtils.sendSuccessEvent(telemetry_1.TelemetryEventName.provisionManifest);
        }
        else {
            telemetry_1.TelemetryUtils.sendErrorEvent(telemetry_1.TelemetryEventName.provisionManifest, result.error);
        }
        return result;
    }
    async updateTeamsApp(ctx, inputs, envInfo, tokenProvider) {
        telemetry_1.TelemetryUtils.init(ctx);
        telemetry_1.TelemetryUtils.sendStartEvent(telemetry_1.TelemetryEventName.updateManifest);
        const result = await appStudio_2.updateTeamsApp(ctx, inputs, envInfo, tokenProvider);
        if (result.isOk()) {
            const properties = {};
            properties[telemetry_1.TelemetryPropertyKey.appId] = result.value;
            telemetry_1.TelemetryUtils.sendSuccessEvent(telemetry_1.TelemetryEventName.updateManifest);
        }
        else {
            telemetry_1.TelemetryUtils.sendErrorEvent(telemetry_1.TelemetryEventName.updateManifest, result.error);
        }
        return result;
    }
    async publishTeamsApp(ctx, inputs, envInfo, tokenProvider) {
        telemetry_1.TelemetryUtils.init(ctx);
        telemetry_1.TelemetryUtils.sendStartEvent(telemetry_1.TelemetryEventName.publish);
        const result = await appStudio_2.publishTeamsApp(ctx, inputs, envInfo, tokenProvider);
        if (result.isOk()) {
            const properties = {};
            properties[telemetry_1.TelemetryPropertyKey.publishedAppId] = result.value.publishedAppId;
            properties[telemetry_1.TelemetryPropertyKey.updateExistingApp] = String(result.value.update);
            telemetry_1.TelemetryUtils.sendSuccessEvent(telemetry_1.TelemetryEventName.publish);
        }
        else {
            telemetry_1.TelemetryUtils.sendErrorEvent(telemetry_1.TelemetryEventName.publish, result.error);
        }
        return result;
    }
    async getTeamsAppId(ctx, inputs, envInfo) {
        let teamsAppId = "";
        // User may manually update id in manifest template file, rather than configuration file
        // The id in manifest template file should override configurations
        const manifestResult = await appStudio_2.getManifest(inputs.projectPath, envInfo);
        if (manifestResult.isOk()) {
            teamsAppId = manifestResult.value.id;
        }
        if (!isUUID_1.default(teamsAppId)) {
            teamsAppId = envInfo.state[constants_3.ComponentNames.AppManifest].teamsAppId;
        }
        return teamsAppId;
    }
    async listCollaborator(ctx, inputs, envInfo, m365TokenProvider) {
        const teamsAppId = await this.getTeamsAppId(ctx, inputs, envInfo);
        if (!teamsAppId) {
            return teamsfx_api_1.err(new teamsfx_api_1.UserError(constants_2.Constants.PLUGIN_NAME, "GetConfigError", constants_2.ErrorMessages.GetConfigError(constants_2.Constants.TEAMS_APP_ID, this.name)));
        }
        const appStudioTokenRes = await m365TokenProvider.getAccessToken({ scopes: common_1.AppStudioScopes });
        const appStudioToken = appStudioTokenRes.isOk() ? appStudioTokenRes.value : undefined;
        let userLists;
        try {
            userLists = await appStudio_1.AppStudioClient.getUserList(teamsAppId, appStudioToken);
            if (!userLists) {
                return teamsfx_api_1.ok([]);
            }
        }
        catch (error) {
            if (error.name === 404) {
                error.message = constants_2.ErrorMessages.TeamsAppNotFound(teamsAppId);
            }
            throw error;
        }
        const teamsAppAdmin = userLists
            .filter((userList) => {
            return userList.isAdministrator;
        })
            .map((userList) => {
            return {
                userObjectId: userList.aadId,
                displayName: userList.displayName,
                userPrincipalName: userList.userPrincipalName,
                resourceId: teamsAppId,
            };
        });
        return teamsfx_api_1.ok(teamsAppAdmin);
    }
    async checkPermission(ctx, inputs, envInfo, m365TokenProvider, userInfo) {
        const appStudioTokenRes = await m365TokenProvider.getAccessToken({ scopes: common_1.AppStudioScopes });
        const appStudioToken = appStudioTokenRes.isOk() ? appStudioTokenRes.value : undefined;
        const teamsAppId = await this.getTeamsAppId(ctx, inputs, envInfo);
        if (!teamsAppId) {
            return teamsfx_api_1.err(new teamsfx_api_1.UserError(constants_2.Constants.PLUGIN_NAME, "GetConfigError", constants_2.ErrorMessages.GetConfigError(constants_2.Constants.TEAMS_APP_ID, this.name)));
        }
        const teamsAppRoles = await appStudio_1.AppStudioClient.checkPermission(teamsAppId, appStudioToken, userInfo.aadId);
        const result = [
            {
                name: constants_2.Constants.PERMISSIONS.name,
                roles: [teamsAppRoles],
                type: constants_2.Constants.PERMISSIONS.type,
                resourceId: teamsAppId,
            },
        ];
        return teamsfx_api_1.ok(result);
    }
    async grantPermission(ctx, inputs, envInfo, m365TokenProvider, userInfo) {
        const appStudioTokenRes = await m365TokenProvider.getAccessToken({ scopes: common_1.AppStudioScopes });
        const appStudioToken = appStudioTokenRes.isOk() ? appStudioTokenRes.value : undefined;
        const teamsAppId = await this.getTeamsAppId(ctx, inputs, envInfo);
        if (!teamsAppId) {
            const msgs = constants_2.ErrorMessages.GetConfigError(constants_2.Constants.TEAMS_APP_ID, this.name);
            return teamsfx_api_1.err(new teamsfx_api_1.UserError(constants_2.Constants.PLUGIN_NAME, errors_1.AppStudioError.GrantPermissionFailedError.name, msgs[0], msgs[1]));
        }
        try {
            await appStudio_1.AppStudioClient.grantPermission(teamsAppId, appStudioToken, userInfo);
        }
        catch (error) {
            const msgs = errors_1.AppStudioError.GrantPermissionFailedError.message(error === null || error === void 0 ? void 0 : error.message, teamsAppId);
            return teamsfx_api_1.err(new teamsfx_api_1.UserError(constants_2.Constants.PLUGIN_NAME, errors_1.AppStudioError.GrantPermissionFailedError.name, msgs[0], msgs[1]));
        }
        const result = [
            {
                name: constants_2.Constants.PERMISSIONS.name,
                roles: [constants_2.Constants.PERMISSIONS.admin],
                type: constants_2.Constants.PERMISSIONS.type,
                resourceId: teamsAppId,
            },
        ];
        return teamsfx_api_1.ok(result);
    }
};
AppStudioPluginV3 = tslib_1.__decorate([
    typedi_1.Service(constants_1.BuiltInFeaturePluginNames.appStudio)
], AppStudioPluginV3);
exports.AppStudioPluginV3 = AppStudioPluginV3;
//# sourceMappingURL=index.js.map