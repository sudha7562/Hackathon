"use strict";
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", { value: true });
exports.NodeJSTabFrontendPlugin = void 0;
const tslib_1 = require("tslib");
const hooks_1 = require("@feathersjs/hooks");
const teamsfx_api_1 = require("@microsoft/teamsfx-api");
const path = tslib_1.__importStar(require("path"));
const typedi_1 = require("typedi");
const constants_1 = require("../../../../common/constants");
const templatesActions_1 = require("../../../../common/template-utils/templatesActions");
const tools_1 = require("../../../../common/tools");
const CommonErrorHandlerMW_1 = require("../../../../core/middleware/CommonErrorHandlerMW");
const folder_1 = require("../../../../folder");
const question_1 = require("../../../solution/fx-solution/question");
const solutionSettingsHelper_1 = require("../../../solution/fx-solution/utils/solutionSettingsHelper");
const constants_2 = require("../../../solution/fx-solution/v3/constants");
const constants_3 = require("../../appstudio/constants");
const clients_1 = require("../clients");
const configs_1 = require("../configs");
const constants_4 = require("../constants");
const env_1 = require("../env");
const deploy_1 = require("../ops/deploy");
const errors_1 = require("../resources/errors");
const messages_1 = require("../resources/messages");
const steps_1 = require("../resources/steps");
const templateInfo_1 = require("../resources/templateInfo");
const progress_helper_1 = require("../utils/progress-helper");
const error_1 = require("./error");
let NodeJSTabFrontendPlugin = class NodeJSTabFrontendPlugin {
    constructor() {
        this.name = constants_2.BuiltInFeaturePluginNames.frontend;
        this.displayName = "NodeJS Tab frontend";
        this.description = "Tab frontend with React Framework using Javascript/Typescript";
    }
    async generateCode(ctx, inputs) {
        const solutionSettings = ctx.projectSetting.solutionSettings;
        if (solutionSettings.activeResourcePlugins.includes(this.name))
            return teamsfx_api_1.ok(teamsfx_api_1.Void);
        ctx.logProvider.info(messages_1.Messages.StartScaffold(this.name));
        const progress = await progress_helper_1.ProgressHelper.startProgress(ctx.userInteraction, steps_1.ScaffoldProgress);
        await (progress === null || progress === void 0 ? void 0 : progress.next(steps_1.ScaffoldProgress.steps.Scaffold));
        const language = ctx.projectSetting.programmingLanguage === "typescript" ? "ts" : "js";
        const componentPath = path.join(inputs.projectPath, constants_4.FrontendPathInfo.WorkingDir);
        const hasFunction = solutionSettings
            ? solutionSettings.activeResourcePlugins.includes(constants_2.BuiltInFeaturePluginNames.function)
            : false;
        const variables = {
            showFunction: hasFunction.toString(),
        };
        await templatesActions_1.scaffoldFromTemplates({
            group: templateInfo_1.TemplateInfo.TemplateGroupName,
            lang: language,
            scenario: templateInfo_1.Scenario.Default,
            dst: componentPath,
            fileNameReplaceFn: templatesActions_1.removeTemplateExtReplaceFn,
            fileDataReplaceFn: templatesActions_1.genTemplateRenderReplaceFn(variables),
            onActionEnd: async (action, context) => {
                var _a;
                if (action.name === templatesActions_1.ScaffoldActionName.FetchTemplatesUrlWithTag) {
                    ctx.logProvider.info(messages_1.Messages.getTemplateFrom((_a = context.zipUrl) !== null && _a !== void 0 ? _a : constants_4.Constants.EmptyString));
                }
            },
            onActionError: async (action, context, error) => {
                ctx.logProvider.info(error.toString());
                switch (action.name) {
                    case templatesActions_1.ScaffoldActionName.FetchTemplatesUrlWithTag:
                    case templatesActions_1.ScaffoldActionName.FetchTemplatesZipFromUrl:
                        ctx.logProvider.info(messages_1.Messages.FailedFetchTemplate);
                        break;
                    case templatesActions_1.ScaffoldActionName.FetchTemplateZipFromLocal:
                        throw new errors_1.TemplateZipFallbackError();
                    case templatesActions_1.ScaffoldActionName.Unzip:
                        throw new errors_1.UnzipTemplateError();
                    default:
                        throw new errors_1.UnknownScaffoldError();
                }
            },
        });
        await progress_helper_1.ProgressHelper.endProgress(true);
        ctx.logProvider.info(messages_1.Messages.EndScaffold(this.name));
        return teamsfx_api_1.ok(teamsfx_api_1.Void);
    }
    async generateBicep(ctx, inputs) {
        const solutionSettings = ctx.projectSetting.solutionSettings;
        if (solutionSettings.activeResourcePlugins.includes(this.name))
            return teamsfx_api_1.ok([]);
        const pluginCtx = { plugins: inputs.allPluginsAfterAdd };
        const bicepTemplateDir = path.join(folder_1.getTemplatesFolder(), constants_4.FrontendPathInfo.BicepTemplateRelativeDir);
        const provisionFilePath = path.join(bicepTemplateDir, constants_1.Bicep.ProvisionFileName);
        const moduleProvisionFilePath = path.join(bicepTemplateDir, constants_4.FrontendPathInfo.ModuleProvisionFileName);
        const provisionOrchestration = await tools_1.generateBicepFromFile(provisionFilePath, pluginCtx);
        const provisionModules = await tools_1.generateBicepFromFile(moduleProvisionFilePath, pluginCtx);
        const result = {
            Provision: {
                Orchestration: provisionOrchestration,
                Modules: { frontendHosting: provisionModules },
            },
            Reference: {
                endpoint: constants_4.FrontendOutputBicepSnippet.Endpoint,
                domain: constants_4.FrontendOutputBicepSnippet.Domain,
            },
        };
        return teamsfx_api_1.ok([result]);
    }
    async addInstance(ctx, inputs) {
        solutionSettingsHelper_1.ensureSolutionSettings(ctx.projectSetting);
        const res = await ctx.appManifestProvider.addCapabilities(ctx, inputs, [{ name: "staticTab" }]);
        if (res.isErr())
            return teamsfx_api_1.err(res.error);
        const solutionSettings = ctx.projectSetting.solutionSettings;
        const capabilities = solutionSettings.capabilities;
        if (!capabilities.includes(question_1.TabOptionItem.id)) {
            capabilities.push(question_1.TabOptionItem.id);
        }
        const activeResourcePlugins = solutionSettings.activeResourcePlugins;
        if (!activeResourcePlugins.includes(this.name))
            activeResourcePlugins.push(this.name);
        return teamsfx_api_1.ok([]);
    }
    async updateBicep(ctx, inputs) {
        const result = {
            Reference: {
                endpoint: constants_4.FrontendOutputBicepSnippet.Endpoint,
                domain: constants_4.FrontendOutputBicepSnippet.Domain,
            },
        };
        return teamsfx_api_1.ok([result]);
    }
    async buildFrontendConfig(envInfo, tokenProvider) {
        const credentials = await tokenProvider.getAccountCredentialAsync();
        if (!credentials) {
            return teamsfx_api_1.err(new error_1.UnauthenticatedError());
        }
        const storage = envInfo.state[this.name];
        const frontendConfig = new configs_1.FrontendConfig(tools_1.getSubscriptionIdFromResourceId(storage.storageResourceId), tools_1.getResourceGroupNameFromResourceId(storage.storageResourceId), envInfo.state.solution.location, tools_1.getStorageAccountNameFromResourceId(storage.storageResourceId), credentials);
        return teamsfx_api_1.ok(frontendConfig);
    }
    async updateDotEnv(ctx, inputs, envInfo) {
        const envs = this.collectEnvs(ctx, inputs, envInfo);
        await env_1.saveEnvFile(env_1.envFilePath(envInfo.envName, path.join(inputs.projectPath, constants_4.FrontendPathInfo.WorkingDir)), {
            teamsfxRemoteEnvs: envs,
            customizedRemoteEnvs: {},
        });
        return teamsfx_api_1.ok(teamsfx_api_1.Void);
    }
    collectEnvs(ctx, inputs, envInfo) {
        const envs = {};
        const addToEnvs = (key, value) => {
            // Check for both null and undefined, add to envs when value is "", 0 or false.
            if (value != null) {
                envs[key] = value;
            }
        };
        const solutionSettings = ctx.projectSetting.solutionSettings;
        if (solutionSettings) {
            if (solutionSettings.activeResourcePlugins.includes(constants_2.BuiltInFeaturePluginNames.function)) {
                const functionState = envInfo.state[constants_2.BuiltInFeaturePluginNames.function];
                addToEnvs(env_1.EnvKeys.FuncName, ctx.projectSetting.defaultFunctionName);
                addToEnvs(env_1.EnvKeys.FuncEndpoint, functionState.functionEndpoint);
            }
            if (solutionSettings.activeResourcePlugins.includes(constants_2.BuiltInFeaturePluginNames.simpleAuth)) {
                const simpleAuthState = envInfo.state[constants_2.BuiltInFeaturePluginNames.simpleAuth];
                addToEnvs(env_1.EnvKeys.RuntimeEndpoint, simpleAuthState.endpoint);
                addToEnvs(env_1.EnvKeys.StartLoginPage, constants_4.DependentPluginInfo.StartLoginPageURL);
            }
            if (solutionSettings.activeResourcePlugins.includes(constants_2.BuiltInFeaturePluginNames.aad)) {
                const aadState = envInfo.state[constants_2.BuiltInFeaturePluginNames.aad];
                addToEnvs(env_1.EnvKeys.ClientID, aadState.clientId);
            }
        }
        return envs;
    }
    async configureResource(ctx, inputs, envInfo, tokenProvider) {
        if (envInfo.envName === "local") {
            envInfo.state[this.name][constants_3.FRONTEND_INDEX_PATH] = constants_4.Constants.FrontendIndexPath;
            return teamsfx_api_1.ok(teamsfx_api_1.Void);
        }
        ctx.logProvider.info(messages_1.Messages.StartPostProvision(this.name));
        const progress = await progress_helper_1.ProgressHelper.startProgress(ctx.userInteraction, steps_1.PostProvisionProgress);
        await (progress === null || progress === void 0 ? void 0 : progress.next(steps_1.PostProvisionProgress.steps.EnableStaticWebsite));
        const frontendConfigRes = await this.buildFrontendConfig(envInfo, tokenProvider.azureAccountProvider);
        if (frontendConfigRes.isErr()) {
            return teamsfx_api_1.err(frontendConfigRes.error);
        }
        const client = new clients_1.AzureStorageClient(frontendConfigRes.value);
        try {
            await client.enableStaticWebsite();
        }
        catch (e) {
            return teamsfx_api_1.err(new error_1.EnableStaticWebsiteError());
        }
        await this.updateDotEnv(ctx, inputs, envInfo);
        await progress_helper_1.ProgressHelper.endProgress(true);
        ctx.logProvider.info(messages_1.Messages.EndPostProvision(this.name));
        return teamsfx_api_1.ok(teamsfx_api_1.Void);
    }
    async deploy(ctx, inputs, envInfo, tokenProvider) {
        ctx.logProvider.info(messages_1.Messages.StartDeploy(this.name));
        await progress_helper_1.ProgressHelper.startProgress(ctx.userInteraction, steps_1.DeployProgress);
        const frontendConfigRes = await this.buildFrontendConfig(envInfo, tokenProvider.azureAccountProvider);
        if (frontendConfigRes.isErr()) {
            return teamsfx_api_1.err(frontendConfigRes.error);
        }
        const client = new clients_1.AzureStorageClient(frontendConfigRes.value);
        const componentPath = inputs.dir
            ? inputs.dir
            : path.join(inputs.projectPath, constants_4.FrontendPathInfo.WorkingDir);
        const envName = envInfo.envName;
        await deploy_1.FrontendDeployment.doFrontendBuildV3(componentPath, envName);
        await deploy_1.FrontendDeployment.doFrontendDeploymentV3(client, componentPath, envName);
        await progress_helper_1.ProgressHelper.endProgress(true);
        ctx.logProvider.info(messages_1.Messages.EndDeploy(this.name));
        return teamsfx_api_1.ok(teamsfx_api_1.Void);
    }
};
tslib_1.__decorate([
    hooks_1.hooks([CommonErrorHandlerMW_1.CommonErrorHandlerMW({ telemetry: { component: constants_2.BuiltInFeaturePluginNames.frontend } })]),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [Object, Object]),
    tslib_1.__metadata("design:returntype", Promise)
], NodeJSTabFrontendPlugin.prototype, "generateCode", null);
tslib_1.__decorate([
    hooks_1.hooks([
        CommonErrorHandlerMW_1.CommonErrorHandlerMW({
            telemetry: {
                component: constants_2.BuiltInFeaturePluginNames.frontend,
                eventName: "generate-arm-templates",
            },
        }),
    ]),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [Object, Object]),
    tslib_1.__metadata("design:returntype", Promise)
], NodeJSTabFrontendPlugin.prototype, "generateBicep", null);
tslib_1.__decorate([
    hooks_1.hooks([CommonErrorHandlerMW_1.CommonErrorHandlerMW({ telemetry: { component: constants_2.BuiltInFeaturePluginNames.frontend } })]),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [Object, Object]),
    tslib_1.__metadata("design:returntype", Promise)
], NodeJSTabFrontendPlugin.prototype, "addInstance", null);
tslib_1.__decorate([
    hooks_1.hooks([CommonErrorHandlerMW_1.CommonErrorHandlerMW({ telemetry: { component: constants_2.BuiltInFeaturePluginNames.frontend } })]),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [Object, Object]),
    tslib_1.__metadata("design:returntype", Promise)
], NodeJSTabFrontendPlugin.prototype, "updateBicep", null);
tslib_1.__decorate([
    hooks_1.hooks([CommonErrorHandlerMW_1.CommonErrorHandlerMW({ telemetry: { component: constants_2.BuiltInFeaturePluginNames.frontend } })]),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [Object, Object, Object, Object]),
    tslib_1.__metadata("design:returntype", Promise)
], NodeJSTabFrontendPlugin.prototype, "configureResource", null);
tslib_1.__decorate([
    hooks_1.hooks([CommonErrorHandlerMW_1.CommonErrorHandlerMW({ telemetry: { component: constants_2.BuiltInFeaturePluginNames.frontend } })]),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [Object, Object, Object, Object]),
    tslib_1.__metadata("design:returntype", Promise)
], NodeJSTabFrontendPlugin.prototype, "deploy", null);
NodeJSTabFrontendPlugin = tslib_1.__decorate([
    typedi_1.Service(constants_2.BuiltInFeaturePluginNames.frontend)
], NodeJSTabFrontendPlugin);
exports.NodeJSTabFrontendPlugin = NodeJSTabFrontendPlugin;
//# sourceMappingURL=index.js.map