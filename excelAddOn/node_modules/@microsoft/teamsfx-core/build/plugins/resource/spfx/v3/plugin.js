"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.SPFxPluginImpl = void 0;
const tslib_1 = require("tslib");
const constants_1 = require("../../appstudio/constants");
const error_1 = require("../error");
const constants_2 = require("../utils/constants");
const lodash_1 = tslib_1.__importDefault(require("lodash"));
const questions_1 = require("../utils/questions");
const utils_1 = require("../utils/utils");
const path_1 = tslib_1.__importDefault(require("path"));
const fs_extra_1 = tslib_1.__importDefault(require("fs-extra"));
const teamsfx_api_1 = require("@microsoft/teamsfx-api");
const progress_helper_1 = require("../utils/progress-helper");
const spoClient_1 = require("../spoClient");
const axios_1 = tslib_1.__importDefault(require("axios"));
const folder_1 = require("../../../../folder");
const tools_1 = require("../../../../common/tools");
const localizeUtils_1 = require("../../../../common/localizeUtils");
class SPFxPluginImpl {
    async scaffold(ctx, inputs, componentId) {
        var _a;
        try {
            const webpartName = inputs[questions_1.SPFXQuestionNames.webpart_name];
            const componentName = utils_1.Utils.normalizeComponentName(webpartName);
            const componentNameCamelCase = lodash_1.default.camelCase(componentName);
            const componentClassName = `${componentName}WebPart`;
            const componentStrings = componentClassName + "Strings";
            const libraryName = lodash_1.default.kebabCase((_a = ctx.projectSetting) === null || _a === void 0 ? void 0 : _a.appName);
            let componentAlias = componentClassName;
            if (componentClassName.length > constants_2.Constants.MAX_ALIAS_LENGTH) {
                componentAlias = componentClassName.substring(0, constants_2.Constants.MAX_ALIAS_LENGTH);
            }
            let componentClassNameKebabCase = lodash_1.default.kebabCase(componentClassName);
            if (componentClassNameKebabCase.length > constants_2.Constants.MAX_BUNDLE_NAME_LENGTH) {
                componentClassNameKebabCase = componentClassNameKebabCase.substring(0, constants_2.Constants.MAX_BUNDLE_NAME_LENGTH);
                const lastCharacterIndex = componentClassNameKebabCase.length - 1;
                if (componentClassNameKebabCase[lastCharacterIndex] === "-") {
                    componentClassNameKebabCase = componentClassNameKebabCase.substring(0, lastCharacterIndex);
                }
            }
            const outputFolderPath = `${inputs.projectPath}/SPFx`;
            await fs_extra_1.default.mkdir(outputFolderPath);
            // teams folder
            const teamsDir = `${outputFolderPath}/teams`;
            const templateFolder = path_1.default.join(folder_1.getTemplatesFolder(), "plugins", "resource", "spfx");
            await fs_extra_1.default.mkdir(teamsDir);
            await fs_extra_1.default.copyFile(path_1.default.resolve(templateFolder, "./webpart/base/images/color.png"), `${teamsDir}/${componentId}_color.png`);
            await fs_extra_1.default.copyFile(path_1.default.resolve(templateFolder, "./webpart/base/images/outline.png"), `${teamsDir}/${componentId}_outline.png`);
            // src folder
            const srcDir = `${outputFolderPath}/src`;
            await fs_extra_1.default.mkdir(srcDir);
            await fs_extra_1.default.copyFile(path_1.default.resolve(templateFolder, "./solution/src/index.ts"), `${srcDir}/index.ts`);
            switch (inputs[questions_1.SPFXQuestionNames.framework_type]) {
                case constants_2.Constants.FRAMEWORK_NONE:
                    fs_extra_1.default.mkdirSync(`${srcDir}/webparts/${componentNameCamelCase}`, {
                        recursive: true,
                    });
                    await fs_extra_1.default.copyFile(path_1.default.resolve(templateFolder, "./webpart/none/{componentClassName}.module.scss"), `${srcDir}/webparts/${componentNameCamelCase}/${componentClassName}.module.scss`);
                    await fs_extra_1.default.copyFile(path_1.default.resolve(templateFolder, "./webpart/none/{componentClassName}.ts"), `${srcDir}/webparts/${componentNameCamelCase}/${componentClassName}.ts`);
                    await fs_extra_1.default.copyFile(path_1.default.resolve(templateFolder, "./webpart/none/package.json"), `${outputFolderPath}/package.json`);
                    break;
                case constants_2.Constants.FRAMEWORK_REACT:
                    const componentDir = `${srcDir}/webparts/${componentNameCamelCase}/components`;
                    fs_extra_1.default.mkdirSync(componentDir, { recursive: true });
                    await fs_extra_1.default.copyFile(path_1.default.resolve(templateFolder, "./webpart/react/{componentClassName}.ts"), `${srcDir}/webparts/${componentNameCamelCase}/${componentClassName}.ts`);
                    await fs_extra_1.default.copyFile(path_1.default.resolve(templateFolder, "./webpart/react/components/{componentName}.module.scss"), `${componentDir}/${componentName}.module.scss`);
                    await fs_extra_1.default.copyFile(path_1.default.resolve(templateFolder, "./webpart/react/components/{componentName}.tsx"), `${componentDir}/${componentName}.tsx`);
                    await fs_extra_1.default.copyFile(path_1.default.resolve(templateFolder, "./webpart/react/components/I{componentName}Props.ts"), `${componentDir}/I${componentName}Props.ts`);
                    await fs_extra_1.default.copyFile(path_1.default.resolve(templateFolder, "./webpart/react/package.json"), `${outputFolderPath}/package.json`);
                    break;
            }
            await fs_extra_1.default.copy(path_1.default.resolve(templateFolder, "./webpart/base/loc"), `${srcDir}/webparts/${componentNameCamelCase}/loc`);
            await fs_extra_1.default.copy(path_1.default.resolve(templateFolder, "./webpart/base/{componentClassName}.manifest.json"), `${srcDir}/webparts/${componentNameCamelCase}/${componentClassName}.manifest.json`);
            // config folder
            await fs_extra_1.default.copy(path_1.default.resolve(templateFolder, "./solution/config"), `${outputFolderPath}/config`);
            // Other files
            await fs_extra_1.default.copyFile(path_1.default.resolve(templateFolder, "./solution/README.md"), `${outputFolderPath}/README.md`);
            await fs_extra_1.default.copyFile(path_1.default.resolve(templateFolder, "./solution/_gitignore"), `${outputFolderPath}/.gitignore`);
            await fs_extra_1.default.copyFile(path_1.default.resolve(templateFolder, "./solution/gulpfile.js"), `${outputFolderPath}/gulpfile.js`);
            await fs_extra_1.default.copyFile(path_1.default.resolve(templateFolder, "./solution/tsconfig.json"), `${outputFolderPath}/tsconfig.json`);
            await fs_extra_1.default.copyFile(path_1.default.resolve(templateFolder, "./solution/tslint.json"), `${outputFolderPath}/tslint.json`);
            // Configure placeholders
            const replaceMap = new Map();
            replaceMap.set(constants_2.PlaceHolders.componentName, componentName);
            replaceMap.set(constants_2.PlaceHolders.componentNameCamelCase, componentNameCamelCase);
            replaceMap.set(constants_2.PlaceHolders.componentClassName, componentClassName);
            replaceMap.set(constants_2.PlaceHolders.componentStrings, componentStrings);
            replaceMap.set(constants_2.PlaceHolders.libraryName, libraryName);
            replaceMap.set(constants_2.PlaceHolders.componentId, componentId);
            replaceMap.set(constants_2.PlaceHolders.componentAlias, componentAlias);
            replaceMap.set(constants_2.PlaceHolders.componentDescription, inputs[questions_1.SPFXQuestionNames.webpart_desp]);
            replaceMap.set(constants_2.PlaceHolders.componentNameUnescaped, webpartName);
            replaceMap.set(constants_2.PlaceHolders.componentClassNameKebabCase, componentClassNameKebabCase);
            const appDirectory = await tools_1.getAppDirectory(inputs.projectPath);
            await utils_1.Utils.configure(outputFolderPath, replaceMap);
            await utils_1.Utils.configure(path_1.default.join(appDirectory, constants_1.MANIFEST_TEMPLATE), replaceMap);
            await utils_1.Utils.configure(path_1.default.join(appDirectory, constants_1.MANIFEST_LOCAL), replaceMap);
            return teamsfx_api_1.ok(undefined);
        }
        catch (error) {
            return teamsfx_api_1.err(error_1.ScaffoldError(error));
        }
    }
    async buildSPPackage(ctx, inputs) {
        var _a;
        const progressHandler = await progress_helper_1.ProgressHelper.startPreDeployProgressHandler(ctx.userInteraction);
        if (inputs.platform === teamsfx_api_1.Platform.VSCode) {
            ctx.logProvider.outputChannel.show();
        }
        try {
            const workspacePath = `${inputs.projectPath}/SPFx`;
            await (progressHandler === null || progressHandler === void 0 ? void 0 : progressHandler.next(constants_2.PreDeployProgressMessage.NpmInstall));
            await utils_1.Utils.execute(`npm install`, "SPFx", workspacePath, ctx.logProvider, true);
            const gulpCommand = await SPFxPluginImpl.findGulpCommand(workspacePath);
            await (progressHandler === null || progressHandler === void 0 ? void 0 : progressHandler.next(constants_2.PreDeployProgressMessage.GulpBundle));
            await utils_1.Utils.execute(`${gulpCommand} bundle --ship --no-color`, "SPFx", workspacePath, ctx.logProvider, true);
            await (progressHandler === null || progressHandler === void 0 ? void 0 : progressHandler.next(constants_2.PreDeployProgressMessage.GulpPackage));
            await utils_1.Utils.execute(`${gulpCommand} package-solution --ship --no-color`, "SPFx", workspacePath, ctx.logProvider, true);
            await progress_helper_1.ProgressHelper.endPreDeployProgress(true);
            const sharepointPackage = await this.getPackage(inputs.projectPath);
            if (!(await fs_extra_1.default.pathExists(sharepointPackage))) {
                throw error_1.NoSPPackageError(sharepointPackage);
            }
            const dir = path_1.default.normalize(path_1.default.parse(sharepointPackage).dir);
            if (inputs.platform === teamsfx_api_1.Platform.CLI) {
                const guidance = [
                    {
                        content: "Success: SharePoint package successfully built at ",
                        color: teamsfx_api_1.Colors.BRIGHT_GREEN,
                    },
                    { content: dir, color: teamsfx_api_1.Colors.BRIGHT_MAGENTA },
                ];
                ctx.userInteraction.showMessage("info", guidance, false);
            }
            else {
                const guidance = localizeUtils_1.getLocalizedString("plugins.spfx.buildNotice", dir);
                (_a = ctx.userInteraction) === null || _a === void 0 ? void 0 : _a.showMessage("info", guidance, false, "OK");
            }
            return teamsfx_api_1.ok(undefined);
        }
        catch (error) {
            await progress_helper_1.ProgressHelper.endPreDeployProgress(false);
            return teamsfx_api_1.err(error_1.BuildSPPackageError(error));
        }
    }
    async deploy(ctx, inputs, tokenProvider) {
        var _a, _b, _c, _d, _e, _f, _g, _h;
        const progressHandler = await progress_helper_1.ProgressHelper.startDeployProgressHandler(ctx.userInteraction);
        let success = false;
        try {
            const tenant = await this.getTenant(tokenProvider);
            if (tenant.isErr()) {
                return tenant;
            }
            spoClient_1.SPOClient.setBaseUrl(tenant.value);
            const spoToken = await tools_1.getSPFxToken(tokenProvider.m365TokenProvider);
            if (!spoToken) {
                return teamsfx_api_1.err(error_1.GetSPOTokenFailedError());
            }
            let appCatalogSite = await spoClient_1.SPOClient.getAppCatalogSite(spoToken);
            if (appCatalogSite) {
                spoClient_1.SPOClient.setBaseUrl(appCatalogSite);
            }
            else {
                const res = await ((_a = ctx.userInteraction) === null || _a === void 0 ? void 0 : _a.showMessage("warn", localizeUtils_1.getLocalizedString("plugins.spfx.createAppCatalogNotice", tenant.value), true, "OK", constants_2.Constants.READ_MORE));
                const confirm = (res === null || res === void 0 ? void 0 : res.isOk()) ? res.value : undefined;
                switch (confirm) {
                    case "OK":
                        try {
                            await (progressHandler === null || progressHandler === void 0 ? void 0 : progressHandler.next(constants_2.DeployProgressMessage.CreateSPAppCatalog));
                            await spoClient_1.SPOClient.createAppCatalog(spoToken);
                        }
                        catch (e) {
                            return teamsfx_api_1.err(error_1.CreateAppCatalogFailedError(e));
                        }
                        let retry = 0;
                        appCatalogSite = await spoClient_1.SPOClient.getAppCatalogSite(spoToken);
                        while (appCatalogSite == null && retry < constants_2.Constants.APP_CATALOG_MAX_TIMES) {
                            (_b = ctx.logProvider) === null || _b === void 0 ? void 0 : _b.warning(`No tenant app catalog found, retry: ${retry}`);
                            await utils_1.sleep(constants_2.Constants.APP_CATALOG_REFRESH_TIME);
                            appCatalogSite = await spoClient_1.SPOClient.getAppCatalogSite(spoToken);
                            retry += 1;
                        }
                        if (appCatalogSite) {
                            spoClient_1.SPOClient.setBaseUrl(appCatalogSite);
                            (_c = ctx.logProvider) === null || _c === void 0 ? void 0 : _c.info(`Sharepoint tenant app catalog ${appCatalogSite} created, wait for a few minutes to be active.`);
                            await utils_1.sleep(constants_2.Constants.APP_CATALOG_ACTIVE_TIME);
                        }
                        else {
                            return teamsfx_api_1.err(error_1.CreateAppCatalogFailedError(new Error("Cannot get app catalog site url after creation. You may need wait a few minutes and retry.")));
                        }
                        break;
                    case constants_2.Constants.READ_MORE:
                        (_d = ctx.userInteraction) === null || _d === void 0 ? void 0 : _d.openUrl(constants_2.Constants.CREATE_APP_CATALOG_GUIDE);
                        return teamsfx_api_1.ok(teamsfx_api_1.UserCancelError);
                    default:
                        return teamsfx_api_1.ok(undefined);
                }
            }
            const appPackage = await this.getPackage(inputs.projectPath);
            if (!(await fs_extra_1.default.pathExists(appPackage))) {
                return teamsfx_api_1.err(error_1.NoSPPackageError(appPackage));
            }
            const fileName = path_1.default.parse(appPackage).base;
            const bytes = await fs_extra_1.default.readFile(appPackage);
            try {
                await (progressHandler === null || progressHandler === void 0 ? void 0 : progressHandler.next(constants_2.DeployProgressMessage.UploadAndDeploy));
                await spoClient_1.SPOClient.uploadAppPackage(spoToken, fileName, bytes);
            }
            catch (e) {
                if (((_e = e.response) === null || _e === void 0 ? void 0 : _e.status) === 403) {
                    (_f = ctx.userInteraction) === null || _f === void 0 ? void 0 : _f.showMessage("error", localizeUtils_1.getLocalizedString("plugins.spfx.deployFailedNotice", appCatalogSite), false, "OK");
                    return teamsfx_api_1.err(error_1.InsufficientPermissionError(appCatalogSite));
                }
                else {
                    return teamsfx_api_1.err(error_1.UploadAppPackageFailedError(e));
                }
            }
            const appID = await this.getAppID(inputs.projectPath);
            await spoClient_1.SPOClient.deployAppPackage(spoToken, appID);
            const guidance = localizeUtils_1.getLocalizedString("plugins.spfx.deployNotice", appPackage, appCatalogSite, appCatalogSite);
            if (inputs.platform === teamsfx_api_1.Platform.CLI) {
                (_g = ctx.userInteraction) === null || _g === void 0 ? void 0 : _g.showMessage("info", guidance, false);
            }
            else {
                (_h = ctx.userInteraction) === null || _h === void 0 ? void 0 : _h.showMessage("info", guidance, false, "OK");
            }
            success = true;
            return teamsfx_api_1.ok(undefined);
        }
        finally {
            await progress_helper_1.ProgressHelper.endDeployProgress(success);
        }
    }
    async getAppID(root) {
        const solutionConfig = await fs_extra_1.default.readJson(`${root}/SPFx/config/package-solution.json`);
        const appID = solutionConfig["solution"]["id"];
        return appID;
    }
    async getTenant(tokenProvider) {
        var _a, _b;
        const graphTokenRes = await ((_a = tokenProvider.m365TokenProvider) === null || _a === void 0 ? void 0 : _a.getAccessToken({
            scopes: tools_1.GraphScopes,
        }));
        const graphToken = graphTokenRes.isOk() ? graphTokenRes.value : undefined;
        if (!graphToken) {
            return teamsfx_api_1.err(error_1.GetGraphTokenFailedError());
        }
        const tokenJsonRes = await ((_b = tokenProvider.m365TokenProvider) === null || _b === void 0 ? void 0 : _b.getJsonObject({
            scopes: tools_1.GraphScopes,
        }));
        const username = tokenJsonRes.value.unique_name;
        const instance = axios_1.default.create({
            baseURL: "https://graph.microsoft.com/v1.0",
        });
        instance.defaults.headers.common["Authorization"] = `Bearer ${graphToken}`;
        let tenant = "";
        try {
            const res = await instance.get("/sites/root?$select=webUrl");
            if (res && res.data && res.data.webUrl) {
                tenant = res.data.webUrl;
            }
            else {
                return teamsfx_api_1.err(error_1.GetTenantFailedError(username));
            }
        }
        catch (e) {
            return teamsfx_api_1.err(error_1.GetTenantFailedError(username, e));
        }
        return teamsfx_api_1.ok(tenant);
    }
    static async findGulpCommand(rootPath) {
        let gulpCommand;
        const platform = process.platform;
        if (platform === "win32" &&
            (await fs_extra_1.default.pathExists(path_1.default.join(rootPath, "node_modules", ".bin", "gulp.cmd")))) {
            gulpCommand = path_1.default.join(".", "node_modules", ".bin", "gulp.cmd");
        }
        else if ((platform === "linux" || platform === "darwin") &&
            (await fs_extra_1.default.pathExists(path_1.default.join(rootPath, "node_modules", ".bin", "gulp")))) {
            gulpCommand = path_1.default.join(".", "node_modules", ".bin", "gulp");
        }
        else {
            gulpCommand = "gulp";
        }
        return gulpCommand;
    }
    async getPackage(root) {
        const solutionConfig = await fs_extra_1.default.readJson(`${root}/SPFx/config/package-solution.json`);
        const sharepointPackage = `${root}/SPFx/sharepoint/${solutionConfig.paths.zippedPackage}`;
        return sharepointPackage;
    }
}
exports.SPFxPluginImpl = SPFxPluginImpl;
//# sourceMappingURL=plugin.js.map