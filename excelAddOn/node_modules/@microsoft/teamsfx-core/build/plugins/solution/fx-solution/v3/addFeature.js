"use strict";
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", { value: true });
exports.addFeature = exports.DefaultManifestProvider = exports.getQuestionsForAddFeature = void 0;
const tslib_1 = require("tslib");
const teamsfx_api_1 = require("@microsoft/teamsfx-api");
const typedi_1 = require("typedi");
const questions_1 = require("../../utils/questions");
const arm_1 = tslib_1.__importDefault(require("../arm"));
const constants_1 = require("./constants");
const solutionSettingsHelper_1 = require("../utils/solutionSettingsHelper");
const question_1 = require("../../../../core/question");
const question_2 = require("../question");
const scaffolding_1 = require("../debug/scaffolding");
const lodash_1 = require("lodash");
const projectSettingsHelper_1 = require("../../../../common/projectSettingsHelper");
function getAllFeaturePlugins() {
    return [
        typedi_1.Container.get(constants_1.BuiltInFeaturePluginNames.frontend),
        typedi_1.Container.get(constants_1.BuiltInFeaturePluginNames.bot),
        typedi_1.Container.get(constants_1.BuiltInFeaturePluginNames.aad),
        typedi_1.Container.get(constants_1.BuiltInFeaturePluginNames.function),
        typedi_1.Container.get(constants_1.BuiltInFeaturePluginNames.apim),
        typedi_1.Container.get(constants_1.BuiltInFeaturePluginNames.keyVault),
        typedi_1.Container.get(constants_1.BuiltInFeaturePluginNames.identity),
        typedi_1.Container.get(constants_1.BuiltInFeaturePluginNames.sql),
        typedi_1.Container.get(constants_1.BuiltInFeaturePluginNames.spfx),
    ];
}
async function getQuestionsForAddFeature(ctx, inputs) {
    const node = new teamsfx_api_1.QTreeNode({ type: "group" });
    const plugins = getAllFeaturePlugins();
    const featureNode = new teamsfx_api_1.QTreeNode(questions_1.selectMultipleFeaturesQuestion);
    if (!ctx.projectSetting.programmingLanguage) {
        const programmingLanguage = new teamsfx_api_1.QTreeNode(question_1.ProgrammingLanguageQuestion);
        node.addChild(programmingLanguage);
    }
    const staticOptions = [];
    for (const plugin of plugins) {
        staticOptions.push({
            id: plugin.name,
            label: plugin.description || plugin.displayName || plugin.name,
        });
        if (plugin.getQuestionsForAddInstance) {
            const childNode = await plugin.getQuestionsForAddInstance(ctx, inputs);
            if (childNode.isErr())
                return teamsfx_api_1.err(childNode.error);
            if (childNode.value) {
                childNode.value.condition = { contains: plugin.name };
                featureNode.addChild(childNode.value);
            }
        }
    }
    questions_1.selectMultipleFeaturesQuestion.staticOptions = staticOptions;
    node.addChild(featureNode);
    return teamsfx_api_1.ok(node);
}
exports.getQuestionsForAddFeature = getQuestionsForAddFeature;
class DefaultManifestProvider {
    async updateCapability(ctx, inputs, capability) {
        const appStudioV3 = typedi_1.Container.get(constants_1.BuiltInFeaturePluginNames.appStudio);
        return await appStudioV3.updateCapability(ctx, inputs, capability);
    }
    async deleteCapability(ctx, inputs, capability) {
        const appStudioV3 = typedi_1.Container.get(constants_1.BuiltInFeaturePluginNames.appStudio);
        return await appStudioV3.deleteCapability(ctx, inputs, capability);
    }
    async capabilityExceedLimit(ctx, inputs, capability) {
        const appStudioV3 = typedi_1.Container.get(constants_1.BuiltInFeaturePluginNames.appStudio);
        return await appStudioV3.capabilityExceedLimit(ctx, inputs, capability);
    }
    async addCapabilities(ctx, inputs, capabilities) {
        const appStudioV3 = typedi_1.Container.get(constants_1.BuiltInFeaturePluginNames.appStudio);
        const res = await appStudioV3.addCapabilities(ctx, inputs, capabilities);
        if (res.isErr())
            return teamsfx_api_1.err(res.error);
        return teamsfx_api_1.ok(teamsfx_api_1.Void);
    }
}
exports.DefaultManifestProvider = DefaultManifestProvider;
async function addFeature(ctx, inputs, telemetryProps) {
    solutionSettingsHelper_1.ensureSolutionSettings(ctx.projectSetting);
    if (!ctx.projectSetting.programmingLanguage && inputs[question_1.ProgrammingLanguageQuestion.name])
        ctx.projectSetting.programmingLanguage = inputs[question_1.ProgrammingLanguageQuestion.name];
    let solutionSettings = ctx.projectSetting.solutionSettings;
    const existingSet = new Set();
    let newSet = new Set();
    solutionSettings.activeResourcePlugins.forEach((p) => {
        existingSet.add(p);
    });
    inputs.features.forEach((f) => {
        newSet.add(f);
    });
    const contextWithManifestProvider = Object.assign(Object.assign({}, ctx), { appManifestProvider: new DefaultManifestProvider() });
    const projectSettingsOld = lodash_1.cloneDeep(ctx.projectSetting);
    const resolveRes = await resolveResourceDependencies(contextWithManifestProvider, inputs, existingSet, newSet);
    const projectSettingsNew = ctx.projectSetting;
    if (resolveRes.isErr())
        return teamsfx_api_1.err(resolveRes.error);
    newSet = resolveRes.value;
    newSet.forEach((s) => {
        existingSet.delete(s);
    });
    const existingArray = Array.from(existingSet);
    const newArray = Array.from(newSet);
    const allPluginsAfterAdd = existingArray.concat(newArray);
    const addFeatureInputs = Object.assign(Object.assign({}, inputs), { allPluginsAfterAdd: allPluginsAfterAdd });
    contextWithManifestProvider.projectSetting = projectSettingsOld;
    for (const pluginName of newArray) {
        const plugin = typedi_1.Container.get(pluginName);
        if (plugin.generateCode) {
            const res = await plugin.generateCode(contextWithManifestProvider, addFeatureInputs);
            if (res.isErr())
                return teamsfx_api_1.err(res.error);
        }
    }
    const bicepRes = await arm_1.default.generateBicep(contextWithManifestProvider, inputs, newArray, existingArray);
    if (bicepRes.isErr()) {
        return teamsfx_api_1.err(bicepRes.error);
    }
    ctx.projectSetting = projectSettingsNew;
    solutionSettings = ctx.projectSetting.solutionSettings;
    if (projectSettingsHelper_1.hasAzureResource(ctx.projectSetting)) {
        solutionSettings.hostType = question_2.HostTypeOptionAzure.id;
    }
    else if (projectSettingsHelper_1.hasSPFx(ctx.projectSetting)) {
        solutionSettings.hostType = question_2.HostTypeOptionSPFx.id;
    }
    const scaffoldRes = await scaffolding_1.scaffoldLocalDebugSettings(ctx, inputs, undefined, false);
    if (scaffoldRes.isErr())
        return teamsfx_api_1.err(scaffoldRes.error);
    return teamsfx_api_1.ok(teamsfx_api_1.Void);
}
exports.addFeature = addFeature;
/**
 * make sure all dependencies in the dependency chain are collected
 * make sure all newly added dependencies's addInstance method are called once
 * @param existingSet existing set
 * @param addedSet set to add
 * @returns new added set (include resolved dependencies in the chain)
 */
async function resolveResourceDependencies(ctx, inputs, existingSet, addedSet) {
    const originalSet = new Set();
    const all = new Set();
    const calledSet = new Set();
    existingSet.forEach((s) => {
        originalSet.add(s);
        all.add(s);
        calledSet.add(s);
    });
    addedSet.forEach((s) => {
        all.add(s);
    });
    // call addInstance APIs for a plugins in addedSet
    for (const pluginName of addedSet.values()) {
        const plugin = typedi_1.Container.get(pluginName);
        if (plugin.addInstance) {
            const depRes = await plugin.addInstance(ctx, inputs);
            if (depRes.isErr()) {
                return teamsfx_api_1.err(depRes.error);
            }
            calledSet.add(pluginName);
            for (const dep of depRes.value) {
                all.add(dep);
            }
        }
    }
    // check all to make all dependencies are resolved
    while (true) {
        const size1 = all.size;
        for (const pluginName of all.values()) {
            const plugin = typedi_1.Container.get(pluginName);
            if (plugin.addInstance && !calledSet.has(pluginName)) {
                const depRes = await plugin.addInstance(ctx, inputs);
                if (depRes.isErr()) {
                    return teamsfx_api_1.err(depRes.error);
                }
                calledSet.add(pluginName);
                for (const dep of depRes.value) {
                    all.add(dep);
                }
            }
        }
        const size2 = all.size;
        if (size1 === size2)
            break;
    }
    const netSet = new Set();
    for (const pluginName of all.values()) {
        if (!originalSet.has(pluginName)) {
            netSet.add(pluginName);
        }
    }
    addedSet.forEach((s) => {
        netSet.add(s);
    });
    return teamsfx_api_1.ok(netSet);
}
//# sourceMappingURL=addFeature.js.map