"use strict";
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", { value: true });
exports.deployAadFromVscode = exports.TeamsfxCore = void 0;
const tslib_1 = require("tslib");
const teamsfx_api_1 = require("@microsoft/teamsfx-api");
const fs_extra_1 = tslib_1.__importDefault(require("fs-extra"));
const path_1 = tslib_1.__importDefault(require("path"));
require("reflect-metadata");
const typedi_1 = require("typedi");
const question_1 = require("../core/question");
const projectSettingsHelper_1 = require("./../common/projectSettingsHelper");
require("./bicep");
require("./code/apiCode");
require("./code/botCode");
require("./code/spfxTabCode");
require("./code/tabCode");
require("./connection/apimConfig");
require("./connection/azureFunctionConfig");
require("./connection/azureWebAppConfig");
const debug_1 = require("./debug");
const envManager_1 = require("./envManager");
require("./feature/api");
require("./feature/apiConnector");
require("./feature/apim");
require("./feature/bot");
require("./feature/cicd");
require("./feature/keyVault");
require("./feature/spfx");
require("./feature/sql");
require("./feature/sso");
require("./feature/tab");
require("./resource/apim");
require("./resource/azureAppService/azureFunction");
require("./resource/azureAppService/azureWebApp");
require("./resource/azureSql");
require("./resource/azureStorage");
require("./resource/botService");
require("./resource/keyVault");
require("./resource/spfx");
require("./resource/aadApp/aadApp");
const jsonschema = tslib_1.__importStar(require("jsonschema"));
const lodash_1 = require("lodash");
const constants_1 = require("../common/constants");
const globalState_1 = require("../common/globalState");
const localizeUtils_1 = require("../common/localizeUtils");
const projectSettingsHelperV3_1 = require("../common/projectSettingsHelperV3");
const tools_1 = require("../common/tools");
const downloadSample_1 = require("../core/downloadSample");
const error_1 = require("../core/error");
const globalVars_1 = require("../core/globalVars");
const arm_1 = tslib_1.__importDefault(require("../plugins/solution/fx-solution/arm"));
const question_2 = require("../plugins/solution/fx-solution/question");
const ResourceGroupHelper_1 = require("../plugins/solution/fx-solution/utils/ResourceGroupHelper");
const executor_1 = require("../plugins/solution/fx-solution/v2/executor");
const utils_1 = require("../plugins/solution/fx-solution/v2/utils");
const deploy_1 = require("../plugins/solution/fx-solution/v3/deploy");
const provision_1 = require("../plugins/solution/fx-solution/v3/provision");
const constants_2 = require("./constants");
const migrate_1 = require("./migrate");
const questionV3_1 = require("./questionV3");
const lib_1 = require("@feathersjs/hooks/lib");
const actionExecutionMW_1 = require("./middleware/actionExecutionMW");
const middleware_1 = require("../core/middleware");
const provision_2 = require("../plugins/solution/fx-solution/v2/provision");
const utils_2 = require("./utils");
const telemetry_1 = require("../common/telemetry");
const workflow_1 = require("./workflow");
const util_1 = require("../plugins/solution/fx-solution/utils/util");
const core_1 = require("../core");
const environment_1 = require("../core/environment");
const telemetry_2 = require("../core/telemetry");
const plugins_1 = require("../plugins");
const constants_3 = require("../plugins/resource/aad/constants");
let TeamsfxCore = class TeamsfxCore {
    constructor() {
        this.name = "fx";
    }
    /**
     * create project
     */
    async create(context, inputs, actionContext) {
        const folder = inputs[question_1.QuestionRootFolder.name];
        if (!folder) {
            return teamsfx_api_1.err(error_1.InvalidInputError("folder is undefined"));
        }
        inputs.folder = folder;
        const scratch = inputs[question_1.CoreQuestionNames.CreateFromScratch];
        let projectPath;
        const automaticNpmInstall = "automaticNpmInstall";
        if (scratch === question_1.ScratchOptionNo.id) {
            // create from sample
            const downloadRes = await downloadSample_1.downloadSample(inputs);
            if (downloadRes.isErr()) {
                return teamsfx_api_1.err(downloadRes.error);
            }
            projectPath = downloadRes.value;
        }
        else {
            // create from new
            const appName = inputs[question_1.CoreQuestionNames.AppName];
            if (undefined === appName)
                return teamsfx_api_1.err(error_1.InvalidInputError(`App Name is empty`, inputs));
            const validateResult = jsonschema.validate(appName, {
                pattern: question_1.ProjectNamePattern,
            });
            if (validateResult.errors && validateResult.errors.length > 0) {
                return teamsfx_api_1.err(error_1.InvalidInputError(`${validateResult.errors[0].message}`, inputs));
            }
            projectPath = path_1.default.join(folder, appName);
            inputs.projectPath = projectPath;
            // set isVS global var when creating project
            globalVars_1.globalVars.isVS = inputs[question_1.CoreQuestionNames.ProgrammingLanguage] === "csharp";
            const initRes = await this.init(context, inputs);
            if (initRes.isErr())
                return teamsfx_api_1.err(initRes.error);
            const features = inputs.capabilities;
            delete inputs.folder;
            if (features === question_2.M365SsoLaunchPageOptionItem.id || features === question_2.M365SearchAppOptionItem.id) {
                context.projectSetting.isM365 = true;
                inputs.isM365 = true;
            }
            if (question_2.BotFeatureIds.includes(features)) {
                inputs[question_2.AzureSolutionQuestionNames.Features] = features;
                const component = typedi_1.Container.get(constants_2.ComponentNames.TeamsBot);
                const res = await component.add(context, inputs);
                if (res.isErr())
                    return teamsfx_api_1.err(res.error);
            }
            if (question_2.TabFeatureIds.includes(features)) {
                inputs[question_2.AzureSolutionQuestionNames.Features] = features;
                const component = typedi_1.Container.get(constants_2.ComponentNames.TeamsTab);
                const res = await component.add(context, inputs);
                if (res.isErr())
                    return teamsfx_api_1.err(res.error);
            }
            if (features === question_2.TabSPFxItem.id) {
                inputs[question_2.AzureSolutionQuestionNames.Features] = features;
                const component = typedi_1.Container.get("spfx-tab");
                const res = await component.add(context, inputs);
                if (res.isErr())
                    return teamsfx_api_1.err(res.error);
            }
            lodash_1.merge(actionContext === null || actionContext === void 0 ? void 0 : actionContext.telemetryProps, {
                [telemetry_1.TelemetryProperty.Feature]: features,
            });
        }
        if (inputs.platform === teamsfx_api_1.Platform.VSCode) {
            await globalState_1.globalStateUpdate(automaticNpmInstall, true);
        }
        context.projectPath = projectPath;
        return teamsfx_api_1.ok(projectPath);
    }
    /**
     * add feature
     */
    async addFeature(context, inputs, actionContext) {
        var _a, _b, _c, _d, _e, _f;
        const features = inputs[question_2.AzureSolutionQuestionNames.Features];
        let component;
        if (question_2.BotFeatureIds.includes(features)) {
            component = typedi_1.Container.get(constants_2.ComponentNames.TeamsBot);
        }
        else if (question_2.TabFeatureIds.includes(features)) {
            component = typedi_1.Container.get(constants_2.ComponentNames.TeamsTab);
        }
        else if (features === question_2.AzureResourceSQLNewUI.id) {
            component = typedi_1.Container.get("sql");
        }
        else if (features === question_2.AzureResourceFunctionNewUI.id) {
            component = typedi_1.Container.get(constants_2.ComponentNames.TeamsApi);
        }
        else if (features === question_2.AzureResourceApim.id) {
            component = typedi_1.Container.get(constants_2.ComponentNames.APIMFeature);
        }
        else if (features === question_2.AzureResourceKeyVaultNewUI.id) {
            component = typedi_1.Container.get("key-vault-feature");
        }
        else if (features === question_2.CicdOptionItem.id) {
            component = typedi_1.Container.get("cicd");
        }
        else if (features === question_2.ApiConnectionOptionItem.id) {
            component = typedi_1.Container.get("api-connector");
        }
        else if (features === question_2.SingleSignOnOptionItem.id) {
            component = typedi_1.Container.get("sso");
        }
        else if (features === question_2.TabSPFxNewUIItem.id) {
            component = typedi_1.Container.get(constants_2.ComponentNames.SPFxTab);
        }
        if (component) {
            const res = await component.add(context, inputs);
            lodash_1.merge(actionContext === null || actionContext === void 0 ? void 0 : actionContext.telemetryProps, {
                [telemetry_1.TelemetryProperty.Feature]: features,
            });
            if (res.isErr())
                return teamsfx_api_1.err(res.error);
            if (features !== question_2.ApiConnectionOptionItem.id && features !== question_2.CicdOptionItem.id) {
                if (((_c = (_b = (_a = context.envInfo) === null || _a === void 0 ? void 0 : _a.state) === null || _b === void 0 ? void 0 : _b.solution) === null || _c === void 0 ? void 0 : _c.provisionSucceeded) === true ||
                    ((_f = (_e = (_d = context.envInfo) === null || _d === void 0 ? void 0 : _d.state) === null || _e === void 0 ? void 0 : _e.solution) === null || _f === void 0 ? void 0 : _f.provisionSucceeded) === "true") {
                    context.envInfo.state.solution.provisionSucceeded = false;
                }
                await environment_1.environmentManager.resetProvisionState(inputs, context);
            }
            return teamsfx_api_1.ok(res.value);
        }
        return teamsfx_api_1.ok(undefined);
    }
    async init(context, inputs) {
        const projectSettings = projectSettingsHelper_1.newProjectSettings();
        projectSettings.appName = inputs["app-name"];
        projectSettings.components = [];
        context.projectSetting = projectSettings;
        await fs_extra_1.default.ensureDir(inputs.projectPath);
        await fs_extra_1.default.ensureDir(path_1.default.join(inputs.projectPath, `.${teamsfx_api_1.ConfigFolderName}`));
        await fs_extra_1.default.ensureDir(path_1.default.join(inputs.projectPath, `.${teamsfx_api_1.ConfigFolderName}`, "configs"));
        const basicFolderRes = await core_1.ensureBasicFolderStructure(inputs);
        if (basicFolderRes.isErr()) {
            return teamsfx_api_1.err(basicFolderRes.error);
        }
        {
            const appManifest = typedi_1.Container.get(constants_2.ComponentNames.AppManifest);
            const res = await appManifest.init(context, inputs);
            if (res.isErr())
                return res;
        }
        {
            const createEnvResult = await envManager_1.createEnvWithName(environment_1.environmentManager.getDefaultEnvName(), projectSettings.appName, inputs);
            if (createEnvResult.isErr()) {
                return teamsfx_api_1.err(createEnvResult.error);
            }
            const createLocalEnvResult = await envManager_1.createEnvWithName(environment_1.environmentManager.getLocalEnvName(), projectSettings.appName, inputs);
            if (createLocalEnvResult.isErr()) {
                return teamsfx_api_1.err(createLocalEnvResult.error);
            }
        }
        return teamsfx_api_1.ok(undefined);
    }
    async provision(ctx, inputs, actionContext) {
        ctx.envInfo.state.solution = ctx.envInfo.state.solution || {};
        ctx.envInfo.state.solution.provisionSucceeded = false;
        // 1. pre provision
        {
            const res = await preProvision(ctx, inputs);
            if (res.isErr())
                return teamsfx_api_1.err(res.error);
        }
        // 2. create a teams app
        const appManifest = typedi_1.Container.get(constants_2.ComponentNames.AppManifest);
        {
            const res = await appManifest.provision(ctx, inputs);
            if (res.isErr())
                return teamsfx_api_1.err(res.error);
        }
        // 3. call resources provision api
        const componentsToProvision = ctx.projectSetting.components.filter((r) => r.provision);
        {
            const thunks = [];
            for (const componentConfig of componentsToProvision) {
                const componentInstance = typedi_1.Container.get(componentConfig.name);
                if (componentInstance.provision) {
                    thunks.push({
                        pluginName: `${componentConfig.name}`,
                        taskName: "provision",
                        thunk: () => {
                            ctx.envInfo.state[componentConfig.name] =
                                ctx.envInfo.state[componentConfig.name] || {};
                            return componentInstance.provision(ctx, inputs);
                        },
                    });
                }
            }
            const provisionResult = await executor_1.executeConcurrently(thunks, ctx.logProvider);
            if (provisionResult.kind !== "success") {
                return teamsfx_api_1.err(provisionResult.error);
            }
            ctx.logProvider.info(localizeUtils_1.getLocalizedString("core.provision.ProvisionFinishNotice", constants_1.PluginDisplayName.Solution));
        }
        // 4
        if (ctx.envInfo.envName === "local") {
            //4.1 setup local env
            const localEnvSetupResult = await debug_1.setupLocalEnvironment(ctx, inputs);
            if (localEnvSetupResult.isErr()) {
                return teamsfx_api_1.err(localEnvSetupResult.error);
            }
        }
        else if (projectSettingsHelperV3_1.hasAzureResourceV3(ctx.projectSetting)) {
            //4.2 deploy arm templates for remote
            ctx.logProvider.info(localizeUtils_1.getLocalizedString("core.deployArmTemplates.StartNotice", constants_1.PluginDisplayName.Solution));
            const armRes = await arm_1.default.deployArmTemplates(ctx, inputs, ctx.envInfo, ctx.tokenProvider.azureAccountProvider);
            if (armRes.isErr()) {
                return teamsfx_api_1.err(armRes.error);
            }
        }
        // 5.0 "aad-app.setApplicationInContext"
        const aadApp = typedi_1.Container.get(constants_2.ComponentNames.AadApp);
        if (projectSettingsHelperV3_1.hasAAD(ctx.projectSetting)) {
            const res = await aadApp.setApplicationInContext(ctx, inputs);
            if (res.isErr())
                return teamsfx_api_1.err(res.error);
        }
        // 5. call resources configure api
        {
            const thunks = [];
            for (const componentConfig of componentsToProvision) {
                const componentInstance = typedi_1.Container.get(componentConfig.name);
                if (componentInstance.configure) {
                    thunks.push({
                        pluginName: `${componentConfig.name}`,
                        taskName: "configure",
                        thunk: () => {
                            ctx.envInfo.state[componentConfig.name] =
                                ctx.envInfo.state[componentConfig.name] || {};
                            return componentInstance.configure(ctx, inputs);
                        },
                    });
                }
            }
            const configResult = await executor_1.executeConcurrently(thunks, ctx.logProvider);
            if (configResult.kind !== "success") {
                return teamsfx_api_1.err(configResult.error);
            }
            ctx.logProvider.info(localizeUtils_1.getLocalizedString("core.provision.configurationFinishNotice", constants_1.PluginDisplayName.Solution));
        }
        // 6.
        if (ctx.envInfo.envName === "local") {
            // 6.1 config local env
            const localConfigResult = await debug_1.configLocalEnvironment(ctx, inputs);
            if (localConfigResult.isErr()) {
                return teamsfx_api_1.err(localConfigResult.error);
            }
        }
        else {
            // 6.2 show message for remote azure provision
            const url = tools_1.getResourceGroupInPortal(ctx.envInfo.state.solution.subscriptionId, ctx.envInfo.state.solution.tenantId, ctx.envInfo.state.solution.resourceGroupName);
            const msg = localizeUtils_1.getLocalizedString("core.provision.successAzure");
            if (url) {
                const title = "View Provisioned Resources";
                ctx.userInteraction.showMessage("info", msg, false, title).then((result) => {
                    const userSelected = result.isOk() ? result.value : undefined;
                    if (userSelected === title) {
                        ctx.userInteraction.openUrl(url);
                    }
                });
            }
            else {
                ctx.userInteraction.showMessage("info", msg, false);
            }
        }
        // 7. update teams app
        {
            const res = await appManifest.configure(ctx, inputs);
            if (res.isErr())
                return teamsfx_api_1.err(res.error);
        }
        // 8. show and set state
        if (ctx.envInfo.envName !== "local") {
            const msg = localizeUtils_1.getLocalizedString("core.provision.successNotice", ctx.projectSetting.appName);
            ctx.userInteraction.showMessage("info", msg, false);
            ctx.logProvider.info(msg);
        }
        lodash_1.merge(actionContext === null || actionContext === void 0 ? void 0 : actionContext.telemetryProps, {
            [telemetry_1.TelemetryProperty.Components]: JSON.stringify(componentsToProvision.map((component) => component.name)),
        });
        ctx.envInfo.state.solution.provisionSucceeded = true;
        return teamsfx_api_1.ok(undefined);
    }
    // async build(
    //   context: ResourceContextV3,
    //   inputs: InputsWithProjectPath
    // ): Promise<Result<undefined, FxError>> {
    //   const projectSettings = context.projectSetting as ProjectSettingsV3;
    //   const thunks = [];
    //   for (const component of projectSettings.components) {
    //     const componentInstance = Container.get(component.name) as any;
    //     if (component.build && componentInstance.build) {
    //       thunks.push({
    //         pluginName: `${component.name}`,
    //         taskName: "build",
    //         thunk: () => {
    //           const clonedInputs = cloneDeep(inputs);
    //           clonedInputs.folder = component.folder;
    //           clonedInputs.artifactFolder = component.artifactFolder;
    //           clonedInputs.componentId = component.name;
    //           return componentInstance.build!(context, clonedInputs);
    //         },
    //       });
    //     }
    //   }
    //   const result = await executeConcurrently(thunks, context.logProvider);
    //   if (result.kind !== "success") {
    //     return err(result.error);
    //   }
    //   return ok(undefined);
    // }
    async deploy(context, inputs, actionContext) {
        const isDeployAADManifestFromVSCode = inputs[constants_3.Constants.INCLUDE_AAD_MANIFEST] === "yes" && inputs.platform === teamsfx_api_1.Platform.VSCode;
        if (isDeployAADManifestFromVSCode) {
            return deployAadFromVscode(context, inputs);
        }
        context.logProvider.info(`inputs(${question_2.AzureSolutionQuestionNames.PluginSelectionDeploy}) = ${inputs[question_2.AzureSolutionQuestionNames.PluginSelectionDeploy]}`);
        const projectSettings = context.projectSetting;
        const inputPlugins = inputs[question_2.AzureSolutionQuestionNames.PluginSelectionDeploy] || [];
        const inputComponentNames = inputPlugins.map(migrate_1.pluginName2ComponentName);
        const thunks = [];
        let hasAzureResource = false;
        // 1. collect resources to deploy
        const isVS = projectSettingsHelper_1.isVSProject(projectSettings);
        for (const component of projectSettings.components) {
            if (component.deploy && (isVS || inputComponentNames.includes(component.name))) {
                const deployComponentName = component.hosting || component.name;
                const featureComponent = typedi_1.Container.get(component.name);
                const deployComponent = typedi_1.Container.get(deployComponentName);
                thunks.push({
                    pluginName: `${component.name}`,
                    taskName: `${featureComponent.build ? "build & " : ""}deploy`,
                    thunk: async () => {
                        const clonedInputs = lodash_1.cloneDeep(inputs);
                        clonedInputs.folder = component.folder;
                        clonedInputs.artifactFolder = component.artifactFolder;
                        clonedInputs.componentId = component.name;
                        if (featureComponent.build) {
                            const buildRes = await featureComponent.build(context, clonedInputs);
                            if (buildRes.isErr())
                                return teamsfx_api_1.err(buildRes.error);
                        }
                        return await deployComponent.deploy(context, clonedInputs);
                    },
                });
                if (constants_2.AzureResources.includes(deployComponentName)) {
                    hasAzureResource = true;
                }
            }
        }
        if (inputComponentNames.includes(constants_2.ComponentNames.AppManifest)) {
            const appManifest = typedi_1.Container.get(constants_2.ComponentNames.AppManifest);
            thunks.push({
                pluginName: constants_2.ComponentNames.AppManifest,
                taskName: "deploy",
                thunk: async () => {
                    return await appManifest.configure(context, inputs);
                },
            });
        }
        if (thunks.length === 0) {
            return teamsfx_api_1.err(new teamsfx_api_1.UserError("fx", "NoResourcePluginSelected", localizeUtils_1.getDefaultString("core.NoPluginSelected"), localizeUtils_1.getLocalizedString("core.NoPluginSelected")));
        }
        context.logProvider.info(localizeUtils_1.getLocalizedString("core.deploy.selectedPluginsToDeployNotice", constants_1.PluginDisplayName.Solution, JSON.stringify(thunks.map((p) => p.pluginName))));
        // 2. check azure account
        if (hasAzureResource) {
            const subscriptionResult = await deploy_1.checkDeployAzureSubscription(context, context.envInfo, context.tokenProvider.azureAccountProvider);
            if (subscriptionResult.isErr()) {
                return teamsfx_api_1.err(subscriptionResult.error);
            }
            const consent = await provision_1.askForDeployConsent(context, context.tokenProvider.azureAccountProvider, context.envInfo);
            if (consent.isErr()) {
                return teamsfx_api_1.err(consent.error);
            }
        }
        // // 3. build
        // {
        //   const res = await this.build(context, inputs);
        //   if (res.isErr()) return err(res.error);
        // }
        // 4. start deploy
        context.logProvider.info(localizeUtils_1.getLocalizedString("core.deploy.startNotice", constants_1.PluginDisplayName.Solution));
        const result = await executor_1.executeConcurrently(thunks, context.logProvider);
        if (result.kind === "success") {
            if (hasAzureResource) {
                const botTroubleShootMsg = utils_1.getBotTroubleShootMessage(projectSettingsHelperV3_1.hasBot(context.projectSetting));
                const msg = localizeUtils_1.getLocalizedString("core.deploy.successNotice", context.projectSetting.appName) +
                    botTroubleShootMsg.textForLogging;
                context.logProvider.info(msg);
                if (botTroubleShootMsg.textForLogging) {
                    // Show a `Learn more` action button for bot trouble shooting.
                    context.userInteraction
                        .showMessage("info", `${localizeUtils_1.getLocalizedString("core.deploy.successNotice", context.projectSetting.appName)} ${botTroubleShootMsg.textForMsgBox}`, false, botTroubleShootMsg.textForActionButton)
                        .then((result) => {
                        const userSelected = result.isOk() ? result.value : undefined;
                        if (userSelected === botTroubleShootMsg.textForActionButton) {
                            context.userInteraction.openUrl(botTroubleShootMsg.troubleShootLink);
                        }
                    });
                }
                else {
                    context.userInteraction.showMessage("info", msg, false);
                }
            }
            lodash_1.merge(actionContext === null || actionContext === void 0 ? void 0 : actionContext.telemetryProps, {
                [telemetry_1.TelemetryProperty.Components]: JSON.stringify(thunks.map((p) => p.pluginName)),
                [telemetry_1.TelemetryProperty.Hosting]: JSON.stringify(thunks.map((p) => { var _a; return (_a = workflow_1.getComponent(projectSettings, p.pluginName)) === null || _a === void 0 ? void 0 : _a.hosting; })),
            });
            return teamsfx_api_1.ok(undefined);
        }
        else {
            const msg = localizeUtils_1.getLocalizedString("core.deploy.failNotice", context.projectSetting.appName);
            context.logProvider.info(msg);
            return teamsfx_api_1.err(result.error);
        }
    }
};
tslib_1.__decorate([
    lib_1.hooks([
        actionExecutionMW_1.ActionExecutionMW({
            question: (context, inputs) => {
                return middleware_1.getQuestionsForCreateProjectV2(inputs);
            },
            enableTelemetry: true,
            telemetryEventName: telemetry_1.TelemetryEvent.CreateProject,
            telemetryComponentName: "core",
        }),
    ]),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [Object, Object, Object]),
    tslib_1.__metadata("design:returntype", Promise)
], TeamsfxCore.prototype, "create", null);
tslib_1.__decorate([
    lib_1.hooks([
        actionExecutionMW_1.ActionExecutionMW({
            question: (context, inputs) => {
                return questionV3_1.getQuestionsForAddFeatureV3(context, inputs);
            },
            enableTelemetry: true,
            telemetryEventName: telemetry_1.TelemetryEvent.AddFeature,
            telemetryComponentName: "core",
        }),
    ]),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [Object, Object, Object]),
    tslib_1.__metadata("design:returntype", Promise)
], TeamsfxCore.prototype, "addFeature", null);
tslib_1.__decorate([
    lib_1.hooks([
        actionExecutionMW_1.ActionExecutionMW({
            question: async (context, inputs) => {
                return await questionV3_1.getQuestionsForProvisionV3(context, inputs);
            },
            enableTelemetry: true,
            telemetryEventName: telemetry_1.TelemetryEvent.Provision,
            telemetryComponentName: "core",
        }),
    ]),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [Object, Object, Object]),
    tslib_1.__metadata("design:returntype", Promise)
], TeamsfxCore.prototype, "provision", null);
tslib_1.__decorate([
    lib_1.hooks([
        actionExecutionMW_1.ActionExecutionMW({
            question: async (context, inputs) => {
                return await questionV3_1.getQuestionsForDeployV3(context, inputs, context.envInfo);
            },
            enableTelemetry: true,
            telemetryEventName: telemetry_1.TelemetryEvent.Deploy,
            telemetryComponentName: "core",
        }),
    ]),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [Object, Object, Object]),
    tslib_1.__metadata("design:returntype", Promise)
], TeamsfxCore.prototype, "deploy", null);
TeamsfxCore = tslib_1.__decorate([
    typedi_1.Service("fx")
], TeamsfxCore);
exports.TeamsfxCore = TeamsfxCore;
async function preProvision(context, inputs) {
    const ctx = context;
    const envInfo = ctx.envInfo;
    const hasBotServiceCreatedBefore = util_1.hasBotServiceCreated(envInfo);
    // 1. check M365 tenant
    envInfo.state[constants_2.ComponentNames.AppManifest] = envInfo.state[constants_2.ComponentNames.AppManifest] || {};
    envInfo.state.solution = envInfo.state.solution || {};
    const appManifest = envInfo.state[constants_2.ComponentNames.AppManifest];
    const solutionConfig = envInfo.state.solution;
    solutionConfig.provisionSucceeded = false;
    const tenantIdInConfig = appManifest.tenantId;
    const isLocalDebug = envInfo.envName === "local";
    const tenantInfoInTokenRes = await provision_1.getM365TenantId(ctx.tokenProvider.m365TokenProvider);
    if (tenantInfoInTokenRes.isErr()) {
        return teamsfx_api_1.err(tenantInfoInTokenRes.error);
    }
    const tenantIdInToken = tenantInfoInTokenRes.value.tenantIdInToken;
    const hasSwitchedM365Tenant = !!tenantIdInConfig && !!tenantIdInToken && tenantIdInToken !== tenantIdInConfig;
    if (!isLocalDebug) {
        if (hasSwitchedM365Tenant) {
            utils_2.resetEnvInfoWhenSwitchM365(envInfo);
        }
    }
    else {
        const res = await utils_1.checkWhetherLocalDebugM365TenantMatches(envInfo, ctx.telemetryReporter, tenantIdInConfig, ctx.tokenProvider.m365TokenProvider, inputs.projectPath);
        if (res.isErr()) {
            return teamsfx_api_1.err(res.error);
        }
    }
    envInfo.state[constants_2.ComponentNames.AppManifest] = envInfo.state[constants_2.ComponentNames.AppManifest] || {};
    envInfo.state[constants_2.ComponentNames.AppManifest].tenantId = tenantIdInToken;
    envInfo.state.solution.teamsAppTenantId = tenantIdInToken;
    globalVars_1.globalVars.m365TenantId = tenantIdInToken;
    // 3. check Azure configs
    if (projectSettingsHelperV3_1.hasAzureResourceV3(ctx.projectSetting) && envInfo.envName !== "local") {
        // ask common question and fill in solution config
        const subscriptionIdInState = envInfo.state.solution.subscriptionId;
        const solutionConfigRes = await provision_1.fillInAzureConfigs(ctx, inputs, envInfo, ctx.tokenProvider);
        if (solutionConfigRes.isErr()) {
            return teamsfx_api_1.err(solutionConfigRes.error);
        }
        const consentResult = await provision_2.askForProvisionConsentNew(ctx, ctx.tokenProvider.azureAccountProvider, envInfo, hasSwitchedM365Tenant, solutionConfigRes.value.hasSwitchedSubscription, tenantInfoInTokenRes.value.tenantUserName, true, tenantIdInConfig, subscriptionIdInState);
        if (consentResult.isErr()) {
            return teamsfx_api_1.err(consentResult.error);
        }
        // create resource group if needed
        if (solutionConfig.needCreateResourceGroup) {
            const createRgRes = await ResourceGroupHelper_1.resourceGroupHelper.createNewResourceGroup(solutionConfig.resourceGroupName, ctx.tokenProvider.azureAccountProvider, solutionConfig.subscriptionId, solutionConfig.location);
            if (createRgRes.isErr()) {
                return teamsfx_api_1.err(createRgRes.error);
            }
        }
        if (solutionConfigRes.value.hasSwitchedSubscription || hasSwitchedM365Tenant) {
            const handleConfigFilesWhenSwitchAccountsRes = await util_1.handleConfigFilesWhenSwitchAccount(envInfo, ctx.projectSetting.appName, inputs.projectPath, hasSwitchedM365Tenant, solutionConfigRes.value.hasSwitchedSubscription, hasBotServiceCreatedBefore);
            if (handleConfigFilesWhenSwitchAccountsRes.isErr()) {
                return teamsfx_api_1.err(handleConfigFilesWhenSwitchAccountsRes.error);
            }
        }
    }
    else if (hasSwitchedM365Tenant && !isLocalDebug) {
        const consentResult = await provision_2.askForProvisionConsentNew(ctx, ctx.tokenProvider.azureAccountProvider, envInfo, hasSwitchedM365Tenant, false, tenantInfoInTokenRes.value.tenantUserName, false, tenantIdInConfig);
        if (consentResult.isErr()) {
            return teamsfx_api_1.err(consentResult.error);
        }
        const handleConfigFilesWhenSwitchAccountsRes = await util_1.handleConfigFilesWhenSwitchAccount(envInfo, ctx.projectSetting.appName, inputs.projectPath, hasSwitchedM365Tenant, false, false);
        if (handleConfigFilesWhenSwitchAccountsRes.isErr()) {
            return teamsfx_api_1.err(handleConfigFilesWhenSwitchAccountsRes.error);
        }
    }
    return teamsfx_api_1.ok(undefined);
}
async function deployAadFromVscode(context, inputs) {
    const thunks = [];
    // 1. collect resources to deploy
    const deployComponent = typedi_1.Container.get(constants_2.ComponentNames.AadApp);
    thunks.push({
        pluginName: `${deployComponent.name}`,
        taskName: `deploy`,
        thunk: async () => {
            const clonedInputs = lodash_1.cloneDeep(inputs);
            clonedInputs.componentId = deployComponent.name;
            return await deployComponent.deploy(context, clonedInputs);
        },
    });
    if (thunks.length === 0) {
        return teamsfx_api_1.err(new teamsfx_api_1.UserError("fx", "NoResourcePluginSelected", localizeUtils_1.getDefaultString("core.NoPluginSelected"), localizeUtils_1.getLocalizedString("core.NoPluginSelected")));
    }
    context.logProvider.info(localizeUtils_1.getLocalizedString("core.deploy.selectedPluginsToDeployNotice", constants_1.PluginDisplayName.Solution, JSON.stringify(thunks.map((p) => p.pluginName))));
    // 2. check azure account
    const subscriptionResult = await deploy_1.checkDeployAzureSubscription(context, context.envInfo, context.tokenProvider.azureAccountProvider);
    if (subscriptionResult.isErr()) {
        return teamsfx_api_1.err(subscriptionResult.error);
    }
    // 3. start deploy
    context.logProvider.info(localizeUtils_1.getLocalizedString("core.deploy.startNotice", constants_1.PluginDisplayName.Solution));
    const result = await executor_1.executeConcurrently(thunks, context.logProvider);
    if (result.kind === "success") {
        const msg = localizeUtils_1.getLocalizedString("core.deploy.aadManifestSuccessNotice");
        context.logProvider.info(msg);
        context.userInteraction
            .showMessage("info", msg, false, localizeUtils_1.getLocalizedString("core.deploy.aadManifestLearnMore"))
            .then((result) => {
            var _a;
            const userSelected = result.isOk() ? result.value : undefined;
            if (userSelected === localizeUtils_1.getLocalizedString("core.deploy.aadManifestLearnMore")) {
                (_a = context.userInteraction) === null || _a === void 0 ? void 0 : _a.openUrl(plugins_1.ViewAadAppHelpLink);
            }
        });
        return teamsfx_api_1.ok(undefined);
    }
    else {
        const msg = localizeUtils_1.getLocalizedString("core.deploy.failNotice", context.projectSetting.appName);
        context.logProvider.info(msg);
        return teamsfx_api_1.err(telemetry_2.sendErrorTelemetryThenReturnError(plugins_1.SolutionTelemetryEvent.Deploy, result.error, context.telemetryReporter));
    }
}
exports.deployAadFromVscode = deployAadFromVscode;
//# sourceMappingURL=core.js.map