"use strict";
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
var BotCodeProvider_1;
Object.defineProperty(exports, "__esModule", { value: true });
exports.BotCodeProvider = void 0;
const tslib_1 = require("tslib");
const lib_1 = require("@feathersjs/hooks/lib");
const teamsfx_api_1 = require("@microsoft/teamsfx-api");
const fs = tslib_1.__importStar(require("fs-extra"));
const lodash_1 = require("lodash");
const path = tslib_1.__importStar(require("path"));
require("reflect-metadata");
const typedi_1 = require("typedi");
const templatesActions_1 = require("../../common/template-utils/templatesActions");
const utils_1 = require("./utils");
const utils_2 = require("../../common/utils");
const question_1 = require("../../core/question");
const constants_1 = require("../../plugins/resource/bot/constants");
const programmingLanguage_1 = require("../../plugins/resource/bot/enums/programmingLanguage");
const errors_1 = require("../../plugins/resource/bot/errors");
const strings_1 = require("../../plugins/resource/bot/resources/strings");
const utils = tslib_1.__importStar(require("../../plugins/resource/bot/utils/common"));
const telemetry_helper_1 = require("../../plugins/resource/bot/utils/telemetry-helper");
const error_1 = require("../../plugins/resource/bot/v3/error");
const constants_2 = require("../constants");
const messages_1 = require("../messages");
const actionExecutionMW_1 = require("../middleware/actionExecutionMW");
const botService_1 = require("../resource/botService");
const workflow_1 = require("../workflow");
const error_2 = require("../error");
/**
 * bot scaffold plugin
 */
let BotCodeProvider = BotCodeProvider_1 = class BotCodeProvider {
    constructor() {
        this.name = "bot-code";
    }
    async generate(context, inputs, actionContext) {
        var _a, _b, _c;
        if (actionContext === null || actionContext === void 0 ? void 0 : actionContext.telemetryProps) {
            lodash_1.merge(actionContext === null || actionContext === void 0 ? void 0 : actionContext.telemetryProps, botService_1.commonTelemetryPropsForBot(context));
        }
        const projectSettings = context.projectSetting;
        const appName = projectSettings.appName;
        const language = (inputs === null || inputs === void 0 ? void 0 : inputs["programming-language"]) ||
            context.projectSetting.programmingLanguage ||
            "javascript";
        const botFolder = (_a = inputs.folder) !== null && _a !== void 0 ? _a : (language === "csharp" ? "" : strings_1.CommonStrings.BOT_WORKING_DIR_NAME);
        const group_name = constants_1.TemplateProjectsConstants.GROUP_NAME_BOT;
        const lang = utils_1.convertToLangKey(language);
        const workingDir = path.join(inputs.projectPath, botFolder);
        const safeProjectName = (_b = inputs[question_1.CoreQuestionNames.SafeProjectName]) !== null && _b !== void 0 ? _b : utils_2.convertToAlphanumericOnly(appName);
        await ((_c = actionContext === null || actionContext === void 0 ? void 0 : actionContext.progressBar) === null || _c === void 0 ? void 0 : _c.next(messages_1.ProgressMessages.scaffoldBot));
        for (const scenario of inputs.scenarios) {
            await templatesActions_1.scaffoldFromTemplates({
                group: group_name,
                lang: lang,
                scenario: scenario,
                dst: workingDir,
                fileDataReplaceFn: templatesActions_1.genTemplateRenderReplaceFn({
                    ProjectName: appName,
                    SafeProjectName: safeProjectName,
                }),
                fileNameReplaceFn: (name, data) => name.replace(/ProjectName/, appName).replace(/\.tpl/, ""),
                onActionError: async (action, context, error) => {
                    switch (action.name) {
                        case templatesActions_1.ScaffoldActionName.FetchTemplatesUrlWithTag:
                        case templatesActions_1.ScaffoldActionName.FetchTemplatesZipFromUrl:
                            break;
                        case templatesActions_1.ScaffoldActionName.FetchTemplateZipFromLocal:
                            throw new error_1.TemplateZipFallbackError();
                        case templatesActions_1.ScaffoldActionName.Unzip:
                            throw new error_1.UnzipError(context.dst);
                        default:
                            throw new Error(error.message);
                    }
                },
            });
        }
        return teamsfx_api_1.ok(undefined);
    }
    async build(context, inputs, actionContext) {
        var _a;
        if (actionContext === null || actionContext === void 0 ? void 0 : actionContext.telemetryProps) {
            lodash_1.merge(actionContext === null || actionContext === void 0 ? void 0 : actionContext.telemetryProps, botService_1.commonTelemetryPropsForBot(context));
        }
        const teamsBot = workflow_1.getComponent(context.projectSetting, constants_2.ComponentNames.TeamsBot);
        if (!teamsBot)
            return teamsfx_api_1.ok(undefined);
        if (teamsBot.folder == undefined)
            throw new error_2.BadComponent("bot", this.name, "folder");
        const packDir = path.resolve(inputs.projectPath, teamsBot.folder);
        const language = context.projectSetting.programmingLanguage || "javascript";
        await ((_a = actionContext === null || actionContext === void 0 ? void 0 : actionContext.progressBar) === null || _a === void 0 ? void 0 : _a.next(messages_1.ProgressMessages.buildingBot));
        if (language === programmingLanguage_1.ProgrammingLanguage.TypeScript) {
            //Typescript needs tsc build before deploy because of windows app server. other languages don"t need it.
            try {
                await utils.execute("npm install", packDir);
                await utils.execute("npm run build", packDir);
                lodash_1.merge(teamsBot, { build: true, artifactFolder: teamsBot.folder });
            }
            catch (e) {
                throw new errors_1.CommandExecutionError(`${strings_1.Commands.NPM_INSTALL}, ${strings_1.Commands.NPM_BUILD}`, packDir, e);
            }
        }
        else if (language === programmingLanguage_1.ProgrammingLanguage.JavaScript) {
            try {
                // fail to npm install @microsoft/teamsfx on azure web app, so pack it locally.
                await utils.execute("npm install", packDir);
                lodash_1.merge(teamsBot, { build: true, artifactFolder: teamsBot.folder });
            }
            catch (e) {
                throw new errors_1.CommandExecutionError(`${strings_1.Commands.NPM_INSTALL}`, packDir, e);
            }
        }
        else if (language === programmingLanguage_1.ProgrammingLanguage.Csharp) {
            const projectFileName = `${context.projectSetting.appName}.csproj`;
            const framework = await BotCodeProvider_1.getFrameworkVersion(path.join(packDir, projectFileName));
            await utils.execute(`dotnet publish --configuration Release`, packDir);
            const artifactFolder = path.join(".", "bin", "Release", framework, "publish");
            lodash_1.merge(teamsBot, { build: true, artifactFolder: artifactFolder });
        }
        return teamsfx_api_1.ok(undefined);
    }
    /**
     * read dotnet framework version from project file
     * @param projectFilePath project base folder
     */
    static async getFrameworkVersion(projectFilePath) {
        try {
            const reg = /(?<=<TargetFramework>)(.*)(?=<)/gim;
            const content = await fs.readFile(projectFilePath, "utf8");
            const framework = content.match(reg);
            if (framework === null || framework === void 0 ? void 0 : framework.length) {
                return framework[0].trim();
            }
        }
        catch (_a) { }
        return constants_1.DEFAULT_DOTNET_FRAMEWORK;
    }
};
tslib_1.__decorate([
    lib_1.hooks([
        actionExecutionMW_1.ActionExecutionMW({
            enableProgressBar: true,
            progressTitle: messages_1.ProgressTitles.scaffoldBot,
            progressSteps: 1,
            errorSource: "bot",
            errorHandler: (e, t) => {
                telemetry_helper_1.telemetryHelper.fillAppStudioErrorProperty(e, t);
                return e;
            },
        }),
    ]),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [Object, Object, Object]),
    tslib_1.__metadata("design:returntype", Promise)
], BotCodeProvider.prototype, "generate", null);
tslib_1.__decorate([
    lib_1.hooks([
        actionExecutionMW_1.ActionExecutionMW({
            enableProgressBar: true,
            progressTitle: messages_1.ProgressTitles.buildingBot,
            progressSteps: 1,
            errorSource: "bot",
        }),
    ]),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [Object, Object, Object]),
    tslib_1.__metadata("design:returntype", Promise)
], BotCodeProvider.prototype, "build", null);
BotCodeProvider = BotCodeProvider_1 = tslib_1.__decorate([
    typedi_1.Service("bot-code")
], BotCodeProvider);
exports.BotCodeProvider = BotCodeProvider;
//# sourceMappingURL=botCode.js.map