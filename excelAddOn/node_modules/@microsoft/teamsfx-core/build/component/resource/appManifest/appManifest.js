"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.addCapabilities = exports.publishQuestion = exports.AppManifest = void 0;
const tslib_1 = require("tslib");
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
const teamsfx_api_1 = require("@microsoft/teamsfx-api");
const fs_extra_1 = tslib_1.__importDefault(require("fs-extra"));
const lodash_1 = require("lodash");
const path = tslib_1.__importStar(require("path"));
require("reflect-metadata");
const typedi_1 = require("typedi");
const url_1 = require("url");
const localizeUtils_1 = require("../../../common/localizeUtils");
const constants_1 = require("../../../common/constants");
const projectSettingsHelperV3_1 = require("../../../common/projectSettingsHelperV3");
const globalVars_1 = require("../../../core/globalVars");
const folder_1 = require("../../../folder");
const question_1 = require("../../../plugins/solution/fx-solution/question");
const constants_2 = require("../../../plugins/resource/appstudio/constants");
const errors_1 = require("../../../plugins/resource/appstudio/errors");
const questions_1 = require("../../../plugins/resource/appstudio/questions");
const results_1 = require("../../../plugins/resource/appstudio/results");
const telemetry_1 = require("../../../plugins/resource/appstudio/utils/telemetry");
const constants_3 = require("../../constants");
const appStudio_1 = require("./appStudio");
const constants_4 = require("./constants");
const utils_1 = require("./utils");
const lib_1 = require("@feathersjs/hooks/lib");
const actionExecutionMW_1 = require("../../middleware/actionExecutionMW");
const utils_2 = require("../../../common/utils");
let AppManifest = class AppManifest {
    constructor() {
        this.name = "app-manifest";
        this.outputs = {
            teamsAppId: {
                key: "teamsAppId",
            },
            tenantId: {
                key: "tenantId",
            },
        };
        this.finalOutputKeys = ["teamsAppId", "tenantId"];
    }
    async init(context, inputs) {
        let manifest;
        const sourceTemplatesFolder = folder_1.getTemplatesFolder();
        if (inputs.capabilities === "TabSPFx") {
            const templateManifestFolder = path.join(sourceTemplatesFolder, "plugins", "resource", "spfx");
            const manifestFile = path.resolve(templateManifestFolder, "./solution/manifest_multi_env.json");
            const manifestString = (await fs_extra_1.default.readFile(manifestFile)).toString();
            manifest = JSON.parse(manifestString);
        }
        else {
            const existingApp = inputs.existingApp;
            const manifestString = constants_4.TEAMS_APP_MANIFEST_TEMPLATE;
            manifest = JSON.parse(manifestString);
            if (existingApp || !projectSettingsHelperV3_1.hasTab(context.projectSetting)) {
                manifest.developer = constants_2.DEFAULT_DEVELOPER;
            }
        }
        const targetTemplateFolder = await utils_2.getProjectTemplatesFolderPath(inputs.projectPath);
        await fs_extra_1.default.ensureDir(targetTemplateFolder);
        const appPackageFolder = path.join(targetTemplateFolder, "appPackage");
        await fs_extra_1.default.ensureDir(appPackageFolder);
        const resourcesFolder = path.resolve(appPackageFolder, "resources");
        await fs_extra_1.default.ensureDir(resourcesFolder);
        const targetManifestPath = path.join(appPackageFolder, "manifest.template.json");
        await fs_extra_1.default.writeFile(targetManifestPath, JSON.stringify(manifest, null, 4));
        const defaultColorPath = path.join(sourceTemplatesFolder, constants_2.COLOR_TEMPLATE);
        const defaultOutlinePath = path.join(sourceTemplatesFolder, constants_2.OUTLINE_TEMPLATE);
        await fs_extra_1.default.copy(defaultColorPath, path.join(resourcesFolder, constants_2.DEFAULT_COLOR_PNG_FILENAME));
        await fs_extra_1.default.copy(defaultOutlinePath, path.join(resourcesFolder, constants_2.DEFAULT_OUTLINE_PNG_FILENAME));
        return teamsfx_api_1.ok(undefined);
    }
    async addCapability(inputs, capabilities) {
        const res = await addCapabilities(inputs, capabilities);
        if (res.isErr())
            return teamsfx_api_1.err(res.error);
        return teamsfx_api_1.ok(undefined);
    }
    async provision(context, inputs, actionContext) {
        var _a;
        const ctx = context;
        await ((_a = actionContext === null || actionContext === void 0 ? void 0 : actionContext.progressBar) === null || _a === void 0 ? void 0 : _a.next(localizeUtils_1.getLocalizedString("plugins.appstudio.provisionProgress", ctx.projectSetting.appName)));
        const res = await appStudio_1.createTeamsApp(ctx, inputs, ctx.envInfo, ctx.tokenProvider);
        if (res.isErr())
            return teamsfx_api_1.err(res.error);
        ctx.envInfo.state[constants_3.ComponentNames.AppManifest].teamsAppId = res.value;
        globalVars_1.globalVars.teamsAppId = res.value;
        return teamsfx_api_1.ok(undefined);
    }
    async configure(context, inputs, actionContext) {
        var _a;
        const ctx = context;
        await ((_a = actionContext === null || actionContext === void 0 ? void 0 : actionContext.progressBar) === null || _a === void 0 ? void 0 : _a.next(localizeUtils_1.getLocalizedString("plugins.appstudio.postProvisionProgress", ctx.projectSetting.appName)));
        const res = await appStudio_1.updateTeamsApp(ctx, inputs, ctx.envInfo, ctx.tokenProvider);
        if (res.isErr())
            return teamsfx_api_1.err(res.error);
        return teamsfx_api_1.ok(undefined);
    }
    async publish(context, inputs, actionCtx) {
        const ctx = context;
        if (inputs.platform === teamsfx_api_1.Platform.VSCode &&
            inputs[constants_2.Constants.BUILD_OR_PUBLISH_QUESTION] === questions_1.manuallySubmitOption.id) {
            if (actionCtx === null || actionCtx === void 0 ? void 0 : actionCtx.telemetryProps)
                actionCtx.telemetryProps[telemetry_1.TelemetryPropertyKey.manual] = String(true);
            try {
                const appPackagePath = await appStudio_1.buildTeamsAppPackage(inputs.projectPath, ctx.envInfo, false, actionCtx.telemetryProps);
                const msg = localizeUtils_1.getLocalizedString("plugins.appstudio.adminApprovalTip", ctx.projectSetting.appName, appPackagePath);
                ctx.userInteraction
                    .showMessage("info", msg, false, "OK", constants_2.Constants.READ_MORE)
                    .then((value) => {
                    if (value.isOk() && value.value === constants_2.Constants.READ_MORE) {
                        ctx.userInteraction.openUrl(constants_2.Constants.PUBLISH_GUIDE);
                    }
                });
                return teamsfx_api_1.ok(undefined);
            }
            catch (error) {
                return teamsfx_api_1.err(results_1.AppStudioResultFactory.UserError(errors_1.AppStudioError.TeamsPackageBuildError.name, errors_1.AppStudioError.TeamsPackageBuildError.message(error), error.helpLink));
            }
        }
        try {
            const res = await appStudio_1.publishTeamsApp(ctx, inputs, ctx.envInfo, ctx.tokenProvider.m365TokenProvider);
            if (res.isErr())
                return teamsfx_api_1.err(res.error);
            ctx.logProvider.info(`Publish success!`);
            if (inputs.platform === teamsfx_api_1.Platform.CLI) {
                const msg = localizeUtils_1.getLocalizedString("plugins.appstudio.publishSucceedNotice.cli", res.value.appName, constants_2.Constants.TEAMS_ADMIN_PORTAL, constants_2.Constants.TEAMS_MANAGE_APP_DOC);
                ctx.userInteraction.showMessage("info", msg, false);
            }
            else {
                const msg = localizeUtils_1.getLocalizedString("plugins.appstudio.publishSucceedNotice", res.value.appName, constants_2.Constants.TEAMS_MANAGE_APP_DOC);
                const adminPortal = localizeUtils_1.getLocalizedString("plugins.appstudio.adminPortal");
                ctx.userInteraction.showMessage("info", msg, false, adminPortal).then((value) => {
                    if (value.isOk() && value.value === adminPortal) {
                        ctx.userInteraction.openUrl(constants_2.Constants.TEAMS_ADMIN_PORTAL);
                    }
                });
            }
            if (actionCtx === null || actionCtx === void 0 ? void 0 : actionCtx.telemetryProps) {
                actionCtx.telemetryProps[telemetry_1.TelemetryPropertyKey.updateExistingApp] = String(res.value.update);
                actionCtx.telemetryProps[telemetry_1.TelemetryPropertyKey.publishedAppId] = String(res.value.publishedAppId);
            }
        }
        catch (error) {
            if (error instanceof teamsfx_api_1.SystemError || error instanceof teamsfx_api_1.UserError) {
                throw error;
            }
            else {
                const publishFailed = new teamsfx_api_1.SystemError({
                    name: errors_1.AppStudioError.TeamsAppPublishFailedError.name,
                    message: error.message,
                    source: constants_2.Constants.PLUGIN_NAME,
                    error: error,
                });
                return teamsfx_api_1.err(publishFailed);
            }
        }
        return teamsfx_api_1.ok(undefined);
    }
    async validate(context, inputs) {
        var _a;
        const manifestRes = await appStudio_1.getManifest(inputs.projectPath, context.envInfo);
        if (manifestRes.isErr()) {
            return teamsfx_api_1.err(manifestRes.error);
        }
        const manifest = manifestRes.value;
        const validationResult = await appStudio_1.validateManifest(manifest);
        if (validationResult.isErr()) {
            return teamsfx_api_1.err(validationResult.error);
        }
        if (validationResult.value.length > 0) {
            const errMessage = errors_1.AppStudioError.ValidationFailedError.message(validationResult.value);
            (_a = context.logProvider) === null || _a === void 0 ? void 0 : _a.error(localizeUtils_1.getLocalizedString("plugins.appstudio.validationFailedNotice"));
            const validationFailed = results_1.AppStudioResultFactory.UserError(errors_1.AppStudioError.ValidationFailedError.name, errMessage);
            return teamsfx_api_1.err(validationFailed);
        }
        const validationSuccess = localizeUtils_1.getLocalizedString("plugins.appstudio.validationSucceedNotice");
        context.userInteraction.showMessage("info", validationSuccess, false);
        return validationResult;
    }
    async build(context, inputs) {
        var _a;
        const res = await appStudio_1.buildTeamsAppPackage(inputs.projectPath, context.envInfo);
        if (res.isOk()) {
            if (inputs.platform === teamsfx_api_1.Platform.CLI || inputs.platform === teamsfx_api_1.Platform.VS) {
                const builtSuccess = [
                    { content: "(√)Done: ", color: teamsfx_api_1.Colors.BRIGHT_GREEN },
                    { content: "Teams Package ", color: teamsfx_api_1.Colors.BRIGHT_WHITE },
                    { content: res.value, color: teamsfx_api_1.Colors.BRIGHT_MAGENTA },
                    { content: " built successfully!", color: teamsfx_api_1.Colors.BRIGHT_WHITE },
                ];
                if (inputs.platform === teamsfx_api_1.Platform.VS) {
                    (_a = context.logProvider) === null || _a === void 0 ? void 0 : _a.info(builtSuccess);
                }
                else {
                    context.userInteraction.showMessage("info", builtSuccess, false);
                }
            }
            else if (inputs.platform === teamsfx_api_1.Platform.VSCode) {
                const isWindows = process.platform === "win32";
                let builtSuccess = localizeUtils_1.getLocalizedString("plugins.appstudio.buildSucceedNotice.fallback", res.value);
                if (isWindows) {
                    const folderLink = url_1.pathToFileURL(path.dirname(res.value));
                    const appPackageLink = `${constants_1.VSCodeExtensionCommand.openFolder}?%5B%22${folderLink}%22%5D`;
                    builtSuccess = localizeUtils_1.getLocalizedString("plugins.appstudio.buildSucceedNotice", appPackageLink);
                }
                context.userInteraction.showMessage("info", builtSuccess, false);
            }
        }
        return res;
    }
    async deploy(context, inputs) {
        return await appStudio_1.updateManifest(context, inputs);
    }
};
tslib_1.__decorate([
    lib_1.hooks([
        actionExecutionMW_1.ActionExecutionMW({
            enableTelemetry: true,
            telemetryComponentName: "AppStudioPlugin",
            telemetryEventName: telemetry_1.TelemetryEventName.init,
        }),
    ]),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [Object, Object]),
    tslib_1.__metadata("design:returntype", Promise)
], AppManifest.prototype, "init", null);
tslib_1.__decorate([
    lib_1.hooks([
        actionExecutionMW_1.ActionExecutionMW({
            enableTelemetry: true,
            telemetryComponentName: "AppStudioPlugin",
            telemetryEventName: telemetry_1.TelemetryEventName.addCapability,
        }),
    ]),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [Object, Array]),
    tslib_1.__metadata("design:returntype", Promise)
], AppManifest.prototype, "addCapability", null);
tslib_1.__decorate([
    lib_1.hooks([
        actionExecutionMW_1.ActionExecutionMW({
            enableProgressBar: true,
            progressTitle: localizeUtils_1.getLocalizedString("plugins.appstudio.provisionTitle"),
            progressSteps: 1,
            enableTelemetry: true,
            telemetryComponentName: "AppStudioPlugin",
            telemetryEventName: telemetry_1.TelemetryEventName.provision,
        }),
    ]),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [Object, Object, Object]),
    tslib_1.__metadata("design:returntype", Promise)
], AppManifest.prototype, "provision", null);
tslib_1.__decorate([
    lib_1.hooks([
        actionExecutionMW_1.ActionExecutionMW({
            enableProgressBar: true,
            progressTitle: localizeUtils_1.getLocalizedString("plugins.appstudio.provisionTitle"),
            progressSteps: 1,
            enableTelemetry: true,
            telemetryComponentName: "AppStudioPlugin",
            telemetryEventName: telemetry_1.TelemetryEventName.localDebug,
        }),
    ]),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [Object, Object, Object]),
    tslib_1.__metadata("design:returntype", Promise)
], AppManifest.prototype, "configure", null);
tslib_1.__decorate([
    lib_1.hooks([
        actionExecutionMW_1.ActionExecutionMW({
            enableTelemetry: true,
            telemetryComponentName: "AppStudioPlugin",
            telemetryEventName: telemetry_1.TelemetryEventName.publish,
            question: async (context, inputs) => {
                return await publishQuestion(inputs);
            },
        }),
    ]),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [Object, Object, Object]),
    tslib_1.__metadata("design:returntype", Promise)
], AppManifest.prototype, "publish", null);
tslib_1.__decorate([
    lib_1.hooks([
        actionExecutionMW_1.ActionExecutionMW({
            enableTelemetry: true,
            telemetryComponentName: "AppStudioPlugin",
            telemetryEventName: telemetry_1.TelemetryEventName.validateManifest,
        }),
    ]),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [Object, Object]),
    tslib_1.__metadata("design:returntype", Promise)
], AppManifest.prototype, "validate", null);
tslib_1.__decorate([
    lib_1.hooks([
        actionExecutionMW_1.ActionExecutionMW({
            enableTelemetry: true,
            telemetryComponentName: "AppStudioPlugin",
            telemetryEventName: telemetry_1.TelemetryEventName.buildTeamsPackage,
        }),
    ]),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [Object, Object]),
    tslib_1.__metadata("design:returntype", Promise)
], AppManifest.prototype, "build", null);
tslib_1.__decorate([
    lib_1.hooks([
        actionExecutionMW_1.ActionExecutionMW({
            enableTelemetry: true,
            telemetryComponentName: "AppStudioPlugin",
            telemetryEventName: telemetry_1.TelemetryEventName.deploy,
        }),
    ]),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [Object, Object]),
    tslib_1.__metadata("design:returntype", Promise)
], AppManifest.prototype, "deploy", null);
AppManifest = tslib_1.__decorate([
    typedi_1.Service("app-manifest")
], AppManifest);
exports.AppManifest = AppManifest;
async function publishQuestion(inputs) {
    if (inputs.platform === teamsfx_api_1.Platform.VSCode) {
        const buildOrPublish = new teamsfx_api_1.QTreeNode({
            name: constants_2.Constants.BUILD_OR_PUBLISH_QUESTION,
            type: "singleSelect",
            staticOptions: [questions_1.manuallySubmitOption, questions_1.autoPublishOption],
            title: localizeUtils_1.getLocalizedString("plugins.appstudio.publishTip"),
            default: questions_1.autoPublishOption.id,
        });
        return teamsfx_api_1.ok(buildOrPublish);
    }
    return teamsfx_api_1.ok(undefined);
}
exports.publishQuestion = publishQuestion;
async function addCapabilities(inputs, capabilities) {
    var _a, _b, _c, _d;
    const appManifestRes = await utils_1.readAppManifest(inputs.projectPath);
    if (appManifestRes.isErr())
        return teamsfx_api_1.err(appManifestRes.error);
    const appManifest = appManifestRes.value;
    for (const capability of capabilities) {
        let staticTabIndex = (_b = (_a = appManifest.staticTabs) === null || _a === void 0 ? void 0 : _a.length) !== null && _b !== void 0 ? _b : 0;
        switch (capability.name) {
            case "staticTab":
                appManifest.staticTabs = appManifest.staticTabs || [];
                if (capability.snippet) {
                    appManifest.staticTabs.push(capability.snippet);
                }
                else {
                    if (capability.existingApp) {
                        const template = lodash_1.cloneDeep(constants_2.STATIC_TABS_TPL_EXISTING_APP[0]);
                        template.entityId = "index" + staticTabIndex;
                        appManifest.staticTabs.push(template);
                    }
                    else {
                        const template = lodash_1.cloneDeep(constants_4.STATIC_TABS_TPL_V3[0]);
                        template.entityId = "index" + staticTabIndex;
                        appManifest.staticTabs.push(template);
                    }
                    staticTabIndex++;
                }
                break;
            case "configurableTab":
                appManifest.configurableTabs = appManifest.configurableTabs || [];
                if (capability.snippet) {
                    appManifest.configurableTabs.push(capability.snippet);
                }
                else {
                    if (capability.existingApp) {
                        appManifest.configurableTabs = appManifest.configurableTabs.concat(constants_2.CONFIGURABLE_TABS_TPL_EXISTING_APP);
                    }
                    else {
                        appManifest.configurableTabs =
                            appManifest.configurableTabs.concat(constants_4.CONFIGURABLE_TABS_TPL_V3);
                    }
                }
                break;
            case "Bot":
                appManifest.bots = appManifest.bots || [];
                if (capability.snippet) {
                    appManifest.bots.push(capability.snippet);
                }
                else {
                    if (capability.existingApp) {
                        appManifest.bots = appManifest.bots.concat(constants_2.BOTS_TPL_EXISTING_APP);
                    }
                    else {
                        if (appManifest.bots === undefined) {
                            appManifest.bots = [];
                        }
                        // import CoreQuestionNames introduces dependency cycle and breaks the whole program
                        // inputs[CoreQuestionNames.Features]
                        const feature = inputs.features;
                        if (feature === question_1.CommandAndResponseOptionItem.id) {
                            // command and response bot
                            appManifest.bots = appManifest.bots.concat(constants_4.BOTS_TPL_FOR_COMMAND_AND_RESPONSE_V3);
                        }
                        else if (feature === question_1.NotificationOptionItem.id) {
                            // notification
                            appManifest.bots = appManifest.bots.concat(constants_4.BOTS_TPL_FOR_NOTIFICATION_V3);
                        }
                        else {
                            // legacy bot
                            appManifest.bots = appManifest.bots.concat(constants_4.BOTS_TPL_V3);
                        }
                    }
                }
                break;
            case "MessageExtension":
                appManifest.composeExtensions = appManifest.composeExtensions || [];
                if (capability.snippet) {
                    appManifest.composeExtensions.push(capability.snippet);
                }
                else {
                    if (capability.existingApp) {
                        appManifest.composeExtensions = appManifest.composeExtensions.concat(constants_2.COMPOSE_EXTENSIONS_TPL_EXISTING_APP);
                    }
                    else {
                        appManifest.composeExtensions =
                            appManifest.composeExtensions.concat(constants_4.COMPOSE_EXTENSIONS_TPL_V3);
                    }
                }
                break;
            case "WebApplicationInfo":
                if (capability.snippet) {
                    appManifest.webApplicationInfo = capability.snippet;
                }
                else {
                    appManifest.webApplicationInfo = constants_4.WEB_APPLICATION_INFO_V3;
                }
                break;
        }
    }
    if (inputs.validDomain && !((_c = appManifest.validDomains) === null || _c === void 0 ? void 0 : _c.includes(inputs.validDomain))) {
        (_d = appManifest.validDomains) === null || _d === void 0 ? void 0 : _d.push(inputs.validDomain);
    }
    await utils_1.writeAppManifest(appManifest, inputs.projectPath);
    return teamsfx_api_1.ok(undefined);
}
exports.addCapabilities = addCapabilities;
//# sourceMappingURL=appManifest.js.map