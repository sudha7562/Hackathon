"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Depot = void 0;
const tslib_1 = require("tslib");
/**
 * As plugins are developed by TS/JS and packed into NPM package, Depot will
 * act like npm but with several differences:
 *
 * 1. Depot will hold all versions of each plugin once loaded.
 * 2. All plugins will be stored in '${home}/${TeamsFx}'.
 *
 *  @example
 *  ~/.fx
 *  ├── manifest.json
 *  └── plugins
 *      ├── bot
 *      │   ├── 1.0.0
 *      │   │   └── node_modules
 *      │   │       └── bot
 *      │   └── 1.1.0
 *      │       └── node_modules
 *      │           └── bot
 *      ├── function
 *      │   └── 1.1.0
 *      │       └── node_modules
 *      │           └── function
 *      ├── keyvault
 *      │   └── 2.0.0
 *      │       └── node_modules
 *      │           └── keyvault
 *      └── ...
 *
 * If there's a resident process, depot will keep all of them in memory. Otherwise,
 * there will be a manifest to optimize performance like an index.
 */
const path_1 = require("path");
const os_1 = require("os");
const fs_extra_1 = require("fs-extra");
const proper_lockfile_1 = require("proper-lockfile");
const teamsfx_api_1 = require("@microsoft/teamsfx-api");
const tools_1 = require("../../common/tools");
const error_1 = require("../error");
const constant_1 = require("./constant");
const utility_1 = require("./utility");
const semver_1 = require("semver");
/**
 * Path is the address of depot to store plugins. Make it static because
 * this property should be immutable.
 */
const DEPOT_ADDR = path_1.join(os_1.homedir(), `.${teamsfx_api_1.ConfigFolderName}`);
/**
 * Write plugins as dependencies in package.json file to execute npm install
 */
async function writePackageJson(targetFolder, plugins) {
    await fs_extra_1.ensureDir(targetFolder);
    const rawData = {
        // name & version are required in package.json
        name: teamsfx_api_1.ProductName,
        version: constant_1.PVM_SPEC_VERSION,
        dependencies: plugins,
    };
    await fs_extra_1.writeFile(path_1.join(targetFolder, constant_1.PACKAGE_DOT_JSON), utility_1.jsonStringifyElegantly(rawData));
}
/**
 * make sure all necessary files/folders are existed.
 */
const ensureDepot = () => {
    /* eslint-disable  @typescript-eslint/no-explicit-any */
    return (target, propertyKey, descriptor) => {
        const originalMethod = descriptor.value;
        descriptor.value = async function (...args) {
            await fs_extra_1.ensureDir(DEPOT_ADDR);
            await fs_extra_1.ensureDir(path_1.join(DEPOT_ADDR, constant_1.PLUGINS_FOLDER));
            if (!(await fs_extra_1.pathExists(path_1.join(DEPOT_ADDR, constant_1.MANIFEST_DOT_JSON)))) {
                const rawData = {
                    // name & version are required in package.json
                    version: constant_1.PVM_SPEC_VERSION,
                    plugins: {},
                };
                await fs_extra_1.writeFile(path_1.join(DEPOT_ADDR, constant_1.MANIFEST_DOT_JSON), utility_1.jsonStringifyElegantly(rawData));
            }
            const result = originalMethod.apply(this, args);
            return result;
        };
    };
};
class Depot {
    /**
     * only support two kinds of package
     * 1. local path
     * 2. semantic version
     *
     * @param packages - the URI of a package
     * @returns True if validation passed
     *
     * TODO use json-schema to validate
     */
    static async validate(plugins) {
        for (const name in plugins) {
            const uri = plugins[name];
            if (semver_1.valid(uri)) {
                continue;
            }
            if (await fs_extra_1.pathExists(path_1.resolve(uri))) {
                continue;
            }
            return false;
        }
        return true;
    }
    /**
     * This is a wrapper of 'npm install' and store all packages in address.
     *
     * npm install {@link https://docs.npmjs.com/cli/v8/commands/npm-install}
     *
     * @param packages - the URI of a package
     * @returns paths of dynamic plugins. If exceptions, return FxError
     */
    static async install(packages) {
        if (!(await Depot.validate(packages))) {
            return teamsfx_api_1.err(error_1.InvalidInputError(Object.keys(packages).toString()));
        }
        const paths = {};
        const versions = {};
        /**
         * lock is necesscary because there might be several process loading plugins.
         */
        try {
            await proper_lockfile_1.lock(DEPOT_ADDR);
        }
        catch (e) {
            return teamsfx_api_1.err(new teamsfx_api_1.ConcurrentError(error_1.CoreSource));
        }
        try {
            for (const name in packages) {
                const uri = packages[name];
                if (await Depot.has(name, uri)) {
                    continue;
                }
                const co = path_1.join(DEPOT_ADDR, constant_1.PLUGINS_FOLDER, name);
                const plugin = {};
                plugin[name] = packages[name];
                // set as "undertermined" and rename after installing
                const source = path_1.join(co, constant_1.UNDERTERMINED);
                await writePackageJson(source, plugin);
                // --prefix set the target diretory of npm package
                // --no-save will not gen package-lock.json
                await tools_1.Executor.execCommandAsync(`npm install --prefix ${source} --cwd ${source} --no-save`);
                // rename the folder by version in node_modules/${name}/package.json
                const config = await fs_extra_1.readJSON(path_1.join(source, constant_1.NODE_MODULES, name, constant_1.PACKAGE_DOT_JSON));
                const version = config.version;
                const destination = path_1.join(co, version);
                // if already installed, overwrite.
                if (await fs_extra_1.pathExists(destination)) {
                    await fs_extra_1.rmdir(destination, { recursive: true });
                }
                await fs_extra_1.move(source, destination);
                // remove temporary package.json
                await fs_extra_1.remove(path_1.join(destination, constant_1.PACKAGE_DOT_JSON));
                paths[name] = destination;
                versions[name] = version;
            }
            // sync to manifest
            Depot.saveManifest(versions);
        }
        catch (e) {
            console.log(e);
            await proper_lockfile_1.unlock(DEPOT_ADDR);
            return teamsfx_api_1.err(error_1.LoadPluginError());
        }
        await proper_lockfile_1.unlock(DEPOT_ADDR);
        return teamsfx_api_1.ok(paths);
    }
    static async getManifest() {
        // sync to manifest
        const manifestPath = path_1.join(DEPOT_ADDR, constant_1.MANIFEST_DOT_JSON);
        const manifest = (await fs_extra_1.readJSON(manifestPath));
        return manifest;
    }
    /**
     * @param name - plugin's name
     * @param version - if set, check specific version of plugin
     *
     * @returns whether plugin is existed or not
     */
    static async has(name, uri) {
        const manifest = await Depot.getManifest();
        if (manifest.plugins[name]) {
            if (uri) {
                const vers = manifest.plugins[name];
                if (vers && vers.includes(uri)) {
                    return true;
                }
            }
            else {
                return true;
            }
        }
        return false;
    }
    static async saveManifest(plugins) {
        // sync to manifest
        const manifestPath = path_1.join(DEPOT_ADDR, constant_1.MANIFEST_DOT_JSON);
        const manifest = (await fs_extra_1.readJSON(manifestPath));
        for (const name in plugins) {
            const version = plugins[name];
            if (manifest.plugins[name]) {
                const vers = manifest.plugins[name];
                if (vers && !vers.includes(version)) {
                    vers.push(plugins[name]);
                    manifest.plugins[name] = vers;
                }
                else {
                    manifest.plugins[name] = [version];
                }
            }
            else {
                manifest.plugins[name] = [version];
            }
        }
        await fs_extra_1.writeFile(manifestPath, utility_1.jsonStringifyElegantly(manifest));
    }
}
tslib_1.__decorate([
    ensureDepot(),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [Object]),
    tslib_1.__metadata("design:returntype", Promise)
], Depot, "install", null);
tslib_1.__decorate([
    ensureDepot(),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", []),
    tslib_1.__metadata("design:returntype", Promise)
], Depot, "getManifest", null);
tslib_1.__decorate([
    ensureDepot(),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [String, String]),
    tslib_1.__metadata("design:returntype", Promise)
], Depot, "has", null);
exports.Depot = Depot;
//# sourceMappingURL=depot.js.map