"use strict";
/**
 *
 * Basic C.R.U.D operations for plugins.
 *
 * Data is persisted in '${ProjectRoot}/${TeamsFx}/package.json'
 *
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.Broker = void 0;
const tslib_1 = require("tslib");
const constant_1 = require("./constant");
const teamsfx_api_1 = require("@microsoft/teamsfx-api");
const fs_extra_1 = require("fs-extra");
const path_1 = require("path");
const error_1 = require("../error");
const utility_1 = require("./utility");
/**
 * make sure all necessary files/folders are existed.
 * Otherwise, throw exception.
 */
const validate = () => {
    /* eslint-disable  @typescript-eslint/no-explicit-any */
    return (target, propertyKey, descriptor) => {
        const originalMethod = descriptor.value;
        descriptor.value = async function (...args) {
            const root = args[0];
            if (!(await fs_extra_1.pathExists(root))) {
                throw new error_1.InvalidProjectError();
            }
            await fs_extra_1.ensureDir(path_1.join(root, teamsfx_api_1.ConfigFolderName));
            if (!(await fs_extra_1.pathExists(path_1.join(root, teamsfx_api_1.ConfigFolderName, constant_1.PLUGIN_DOT_JSON)))) {
                await fs_extra_1.writeFile(path_1.join(root, teamsfx_api_1.ConfigFolderName, constant_1.PLUGIN_DOT_JSON), utility_1.jsonStringifyElegantly({}));
            }
            const result = originalMethod.apply(this, args);
            return result;
        };
    };
};
/**
 * Broker is stateless which means all api should know about the path of
 * target project.
 *
 * All method will throw InvalidProjectError if project is invalid.
 */
class Broker {
    static configPath(root) {
        return path_1.join(root, teamsfx_api_1.ConfigFolderName, constant_1.PLUGIN_DOT_JSON);
    }
    /**
     * both create & update
     */
    static async save(root, plugins) {
        const config = (await fs_extra_1.readJSON(Broker.configPath(root)));
        for (const name in plugins) {
            config[name] = plugins[name];
        }
        await fs_extra_1.writeFile(Broker.configPath(root), utility_1.jsonStringifyElegantly(config));
        return;
    }
    static async list(root) {
        const config = (await fs_extra_1.readJSON(Broker.configPath(root)));
        return config;
    }
    static async remove(root, plugins) {
        const config = (await fs_extra_1.readJSON(Broker.configPath(root)));
        for (const i in plugins) {
            delete config[plugins[i]];
        }
        await fs_extra_1.writeFile(Broker.configPath(root), utility_1.jsonStringifyElegantly(config));
        return;
    }
}
tslib_1.__decorate([
    validate(),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [String, Object]),
    tslib_1.__metadata("design:returntype", Promise)
], Broker, "save", null);
tslib_1.__decorate([
    validate(),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [String]),
    tslib_1.__metadata("design:returntype", Promise)
], Broker, "list", null);
tslib_1.__decorate([
    validate(),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [String, Array]),
    tslib_1.__metadata("design:returntype", Promise)
], Broker, "remove", null);
exports.Broker = Broker;
//# sourceMappingURL=broker.js.map